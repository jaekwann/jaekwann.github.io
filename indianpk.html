<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Hold'em AI : Master Edition</title>
    <style>
        :root { --bg-color: #121212; --table-bg: #1b5e20; --card-bg: #eee; --accent: #ffd700; --danger: #ef5350; }
        body { font-family: 'Segoe UI', Roboto, sans-serif; background: var(--bg-color); color: #e0e0e0; margin: 0; display: flex; justify-content: center; min-height: 100vh; overflow: hidden; }
        
        .container { width: 100%; max-width: 480px; background: #1e1e1e; display: flex; flex-direction: column; height: 100vh; position: relative; box-shadow: 0 0 30px rgba(0,0,0,0.8); }

        /* Loading */
        #loading-screen { position: absolute; inset: 0; background: rgba(18,18,18,0.95); z-index: 100; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        .loader-bar-box { width: 70%; height: 6px; background: #333; border-radius: 3px; margin-top: 15px; overflow: hidden; }
        .loader-bar { height: 100%; width: 0%; background: var(--accent); transition: width 0.2s; }
        
        /* Header & Table */
        .header { padding: 15px; background: #263238; border-bottom: 2px solid #43a047; display: flex; justify-content: space-between; font-weight: bold; font-size: 1.1em; }
        .table { flex: 1; background: radial-gradient(circle at center, #2e7d32 0%, #1b5e20 80%); position: relative; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 20px; }
        
        /* Pot & Status */
        .pot-box { background: rgba(0,0,0,0.6); padding: 8px 25px; border-radius: 30px; border: 1px solid var(--accent); color: var(--accent); font-weight: bold; font-size: 1.2em; margin-bottom: 20px; box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
        .status-msg { color: #bdbdbd; font-style: italic; font-size: 0.9em; min-height: 1.2em; margin-bottom: 10px;}

        /* Players & Cards */
        .play-area { display: flex; width: 100%; justify-content: space-around; align-items: center; margin: 10px 0; }
        .player { text-align: center; position: relative; width: 40%; }
        .p-info { background: rgba(0,0,0,0.5); padding: 4px 10px; border-radius: 4px; font-size: 0.85em; margin-bottom: 8px; display: inline-block; }
        
        .card { 
            width: 70px; height: 105px; background: var(--card-bg); border-radius: 8px; margin: 0 auto;
            display: flex; justify-content: center; align-items: center; font-size: 2.2em; font-weight: bold;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5); position: relative; transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .card.red { color: #c62828; } .card.black { color: #212121; }
        .card.hidden { background: repeating-linear-gradient(45deg, #455a64, #455a64 10px, #37474f 10px, #37474f 20px); color: transparent; border: 2px solid #546e7a; }
        
        /* Effects */
        .card.winner { transform: scale(1.15); box-shadow: 0 0 25px var(--accent); border: 3px solid var(--accent); z-index: 10; }
        .card.loser { opacity: 0.5; filter: grayscale(100%); transform: scale(0.9); }
        .penalty-badge { position: absolute; top: -10px; right: -10px; background: var(--danger); color: white; font-size: 0.7em; padding: 2px 6px; border-radius: 4px; font-weight: bold; animation: popIn 0.3s; }

        /* AI Thought Bubble */
        .ai-brain { 
            width: 90%; background: rgba(255,255,255,0.92); color: #222; padding: 10px; 
            border-radius: 8px; margin-bottom: 15px; font-size: 0.8em; box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            display: none; transform-origin: bottom; animation: floatUp 0.3s;
        }
        .bars { display: flex; height: 8px; border-radius: 4px; overflow: hidden; margin-top: 5px; background: #ddd; }
        .bar-seg { height: 100%; transition: width 0.5s; }
        .b-low { background: #e53935; } .b-mid { background: #fdd835; } .b-high { background: #43a047; }
        .labels { display: flex; justify-content: space-between; font-size: 0.7em; color: #555; margin-top: 2px; }

        /* Controls */
        .controls { padding: 15px; background: #1e1e1e; display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; border-top: 1px solid #333; }
        button { padding: 12px 5px; border: none; border-radius: 6px; color: white; font-weight: bold; font-size: 0.9em; cursor: pointer; transition: transform 0.1s; }
        button:active { transform: scale(0.95); }
        button:disabled { opacity: 0.3; cursor: not-allowed; }
        
        .btn-fold { grid-column: span 1; background: #c62828; }
        .btn-check { grid-column: span 1; background: #2e7d32; }
        .btn-bet { background: #1565c0; }
        .btn-allin { grid-column: span 4; background: #6a1b9a; margin-top: 5px; }

        /* Logs */
        .logs { height: 120px; overflow-y: auto; background: #111; padding: 10px; font-size: 0.8em; color: #bbb; border-top: 1px solid #333; }
        .log-row { margin-bottom: 4px; border-bottom: 1px solid #222; padding-bottom: 2px; }
        .l-ai { color: #ffca28; } .l-user { color: #42a5f5; } .l-sys { color: #90a4ae; font-style: italic; } .l-warn { color: #ef5350; font-weight: bold; }

        @keyframes popIn { 0% {transform: scale(0);} 80% {transform: scale(1.2);} 100% {transform: scale(1);} }
        @keyframes floatUp { from {opacity:0; transform:translateY(10px);} to {opacity:1; transform:translateY(0);} }
    </style>
</head>
<body>

<div class="container">
    <div id="loading-screen">
        <div style="color:var(--accent); font-weight:bold; font-size:1.2em;">Training Neural AI...</div>
        <div class="loader-bar-box"><div class="loader-bar" id="load-bar"></div></div>
        <div style="color:#777; font-size:0.8em; margin-top:10px;">Simulating 10,000 Hands</div>
    </div>

    <div class="header">
        <div>ðŸ¤– AI: <span id="s-ai">100</span></div>
        <div style="color:#888;">R<span id="r-num">1</span></div>
        <div>ðŸ‘¤ You: <span id="s-me">100</span></div>
    </div>

    <div class="table">
        <div class="ai-brain" id="ai-thought">
            <div id="ai-text">Analyzing your betting pattern...</div>
            <div style="margin-top:6px; font-weight:bold; color:#333;">My Estimated Hand Strength:</div>
            <div class="bars">
                <div class="bar-seg b-low" id="b-low" style="width:33%"></div>
                <div class="bar-seg b-mid" id="b-mid" style="width:33%"></div>
                <div class="bar-seg b-high" id="b-high" style="width:33%"></div>
            </div>
            <div class="labels"><span>Weak(1-5)</span><span>Avg(6-8)</span><span>Strong(9-10)</span></div>
        </div>

        <div class="pot-box">POT: <span id="pot">2.0</span></div>

        <div class="play-area">
            <div class="player">
                <div class="p-info">AI (Bet: <span id="b-ai">1</span>)</div>
                <div class="card" id="c-ai">?</div>
            </div>
            <div class="player">
                <div class="p-info">You (Bet: <span id="b-me">1</span>)</div>
                <div class="card hidden" id="c-me">?</div>
            </div>
        </div>
        
        <div class="status-msg" id="status">Wait...</div>
    </div>

    <div class="controls">
        <button class="btn-fold" onclick="act(0)">Fold</button>
        <button class="btn-check" id="btn-chk" onclick="act(1)">Check</button>
        <button class="btn-bet" onclick="act(2)">Bet 33%</button>
        <button class="btn-bet" onclick="act(3)">Bet 75%</button>
        <button class="btn-allin" onclick="act(5)">ALL IN</button>
    </div>
    <div class="logs" id="log-box"></div>
</div>

<script>
/* --- CORE CONSTANTS --- */
const RANKS = [1,2,3,4,5,6,7,8,9,10];
const SUITS = ['s','h','d','c'];
const SYMBOLS = {'s':'â™ ','h':'â™¥','d':'â™¦','c':'â™£'};
const ACT = { FOLD:0, CHECK:1, BET_S:2, BET_L:3, BET_O:4, ALLIN:5 };
const ACT_TXT = ["Fold", "Check/Call", "Bet Small", "Bet Large", "Overbet", "All-In"];
const MULTS = { 2:0.33, 3:0.75, 4:1.5, 5:999 };

/* --- SOLVER ENGINE (MCCFR) --- */
class Node {
    constructor(n) { this.r = new Float32Array(n); this.s = new Float32Array(n); }
    getStrat() {
        let sum = 0; 
        let res = this.r.map(v => { let x = Math.max(v,0); sum+=x; return x; });
        return sum > 0 ? res.map(v => v/sum) : res.map(() => 1/this.r.length);
    }
    getAvgStrat() {
        let sum = this.s.reduce((a,b)=>a+b,0);
        return sum > 0 ? this.s.map(v => v/sum) : this.s.map(() => 1/this.s.length);
    }
}

class Solver {
    constructor() { this.nodes = {}; }
    getNode(key) { if(!this.nodes[key]) this.nodes[key] = new Node(6); return this.nodes[key]; }
    
    // Train using random scenarios
    async train(iters, cb) {
        for(let i=0; i<iters; i+=100) {
            for(let j=0; j<100; j++) {
                let s0 = Math.random()<0.5 ? 100 : Math.floor(Math.random()*150)+20; // Varied stacks
                let st = new State(s0, s0);
                st.turn = Math.random()<0.5 ? 0 : 1;
                this.cfr(st, (i+j)%2, 1, 1);
            }
            if(cb) cb((i+100)/iters);
            await new Promise(r=>setTimeout(r,0));
        }
    }

    cfr(st, p, pr, w) {
        if(st.done) return st.payoff(p);
        let valid = st.validActs();
        if(valid.length===0) return 0;

        // Key: "Opp:[Card I see]|Seq:[History]"
        // Note: Strategy depends on what I SEE (Opponent's card), not my hidden card.
        let key = `Opp:${st.hands[1-st.turn].r}|Seq:${st.hist.join('')}`;
        let node = this.getNode(key);
        let strat = node.getStrat();
        
        // Filter invalid actions
        let probs = new Float32Array(6);
        let sum = 0;
        valid.forEach(a => { probs[a] = strat[a]; sum += strat[a]; });
        if(sum>0) probs = probs.map(v=>v/sum); else valid.forEach(a=>probs[a]=1/valid.length);

        if(st.turn !== p) {
            let r = Math.random(), cum = 0, a = valid[valid.length-1];
            for(let va of valid) { cum += probs[va]; if(r <= cum) { a = va; break; } }
            let next = st.clone(); next.apply(a);
            return this.cfr(next, p, pr, w);
        } else {
            let util = new Float32Array(6), nodeU = 0;
            valid.forEach(a => {
                let next = st.clone(); next.apply(a);
                util[a] = this.cfr(next, p, pr * probs[a], w);
                nodeU += probs[a] * util[a];
            });
            valid.forEach(a => {
                let r = util[a] - nodeU;
                node.r[a] += r * w;
                node.s[a] += (pr * probs[a]) * w;
            });
            return nodeU;
        }
    }
}

/* --- GAME STATE --- */
class State {
    constructor(s0, s1) {
        let deck = [];
        for(let r of RANKS) for(let s of SUITS) deck.push({r,s});
        // Simple Shuffle
        for(let i=deck.length-1; i>0; i--) { let j=Math.floor(Math.random()*(i+1)); [deck[i],deck[j]]=[deck[j],deck[i]]; }
        
        this.hands = [deck.pop(), deck.pop()]; // 0: AI, 1: Human
        this.stacks = [s0-1, s1-1];
        this.bets = [1, 1];
        this.pot = 2;
        this.contrib = [1, 1];
        this.hist = [];
        this.turn = 1; 
        this.done = false;
    }

    validActs() {
        let me = this.turn, opp = 1-me;
        if(this.stacks[me]<=0) return [ACT.FOLD, ACT.CHECK]; // All-in situation
        
        let acts = [ACT.FOLD, ACT.CHECK];
        let diff = this.bets[opp] - this.bets[me];
        let target = this.pot + diff;
        
        for(let a of [2,3,5]) { // Simplified betting options
            if(a===ACT.ALLIN) { acts.push(a); continue; }
            let raise = target * MULTS[a];
            if(diff+raise < this.stacks[me] && raise >= 1) acts.push(a);
        }
        return acts;
    }

    apply(a) {
        this.hist.push(a);
        if(a===ACT.FOLD) { this.done = true; return; }
        
        let me = this.turn, opp = 1-me;
        let diff = this.bets[opp] - this.bets[me];
        let amt = (a===ACT.CHECK) ? Math.min(diff, this.stacks[me]) :
                  (a===ACT.ALLIN) ? this.stacks[me] :
                  Math.min(this.stacks[me], diff + (this.pot+diff)*MULTS[a]);
        
        this.stacks[me] -= amt; this.bets[me] += amt; this.contrib[me] += amt; this.pot += amt;

        if(a===ACT.CHECK && this.bets[0]===this.bets[1] && this.hist.length>=1) {
            if(this.hist.length>=2 || diff>0) this.done = true;
        }
        if(!this.done) this.turn = opp;
    }

    payoff(p) {
        let opp = 1-p;
        let last = this.hist[this.hist.length-1];
        
        // FOLD LOGIC with 10 PENALTY
        if(last === ACT.FOLD) {
            let folder = this.turn; // The person who acted FOLD
            let winner = 1-folder;
            let penalty = (this.hands[folder].r === 10) ? 10 : 0; // Rule 1: Penalty 10
            
            let winAmt = this.pot - this.contrib[p]; // Net profit
            if(p === winner) return winAmt + penalty; // Winner gets pot + penalty
            else return -this.contrib[p] - penalty;   // Loser loses contrib + penalty
        }
        
        // Showdown
        let r1 = this.hands[p].r, r2 = this.hands[opp].r;
        if(r1 > r2) return this.pot - this.contrib[p];
        if(r1 < r2) return -this.contrib[p];
        return 0; // Tie
    }
    
    clone() {
        let s = new State(0,0);
        s.hands=[...this.hands]; s.stacks=[...this.stacks]; s.bets=[...this.bets];
        s.pot=this.pot; s.contrib=[...this.contrib]; s.hist=[...this.hist]; 
        s.turn=this.turn; s.done=this.done;
        return s;
    }
}

/* --- MAIN & UI --- */
const solver = new Solver();
let game = null, round = 0;
let chips = [100, 100]; // 0: AI, 1: User

window.onload = () => {
    solver.train(10000, (pct) => {
        document.getElementById('load-bar').style.width = (pct*100)+'%';
    }).then(() => {
        document.getElementById('loading-screen').style.display = 'none';
        startRound();
    });
};

function log(msg, cls) {
    let div = document.createElement('div');
    div.className = 'log-row '+cls; div.innerText = msg;
    let box = document.getElementById('log-box');
    box.appendChild(div); box.scrollTop = box.scrollHeight;
}

function updateUI(showHidden = false) {
    document.getElementById('s-ai').innerText = chips[0].toFixed(0);
    document.getElementById('s-me').innerText = chips[1].toFixed(0);
    document.getElementById('pot').innerText = game.pot.toFixed(0);
    document.getElementById('b-ai').innerText = game.bets[0].toFixed(0);
    document.getElementById('b-me').innerText = game.bets[1].toFixed(0);
    document.getElementById('r-num').innerText = round;

    let c0 = game.hands[0], c1 = game.hands[1];
    let el0 = document.getElementById('c-ai');
    el0.innerText = c0.r; el0.className = `card ${['h','d'].includes(c0.s)?'red':'black'}`;
    
    let el1 = document.getElementById('c-me');
    if(showHidden) {
        el1.innerText = c1.r; el1.className = `card ${['h','d'].includes(c1.s)?'red':'black'}`;
        // Remove penalty badge if exists
        let badges = document.querySelectorAll('.penalty-badge');
        badges.forEach(b => b.remove());
        // Show penalty badge if 10 and Folded
        if(game.hist[game.hist.length-1] === ACT.FOLD) {
             // Logic handled in endRound animation
        }
    } else {
        el1.innerText = "?"; el1.className = "card hidden";
    }

    let btns = document.querySelectorAll('.controls button');
    let valid = game.validActs();
    btns.forEach(b => b.disabled = true);
    
    if(!game.done && game.turn === 1) {
        let diff = game.bets[0] - game.bets[1];
        document.getElementById('btn-chk').innerText = diff===0 ? "Check" : `Call (${diff})`;
        if(valid.includes(0)) btns[0].disabled = false;
        if(valid.includes(1)) btns[1].disabled = false;
        if(valid.includes(2)) btns[2].disabled = false;
        if(valid.includes(3)) btns[3].disabled = false;
        if(valid.includes(5)) btns[4].disabled = false;
        document.getElementById('status').innerText = "Your Turn";
    } else {
        document.getElementById('status').innerText = game.done ? "Round Over" : "AI Thinking...";
    }
}

function startRound() {
    if(chips[0]<=0 || chips[1]<=0) { alert(chips[0]<=0?"You Win Game!":"You Lose Game!"); return; }
    round++;
    game = new State(chips[0], chips[1]);
    document.getElementById('ai-thought').style.display = 'none';
    
    // Clean card styles
    document.querySelectorAll('.card').forEach(c => {
        c.classList.remove('winner', 'loser');
        let b = c.querySelector('.penalty-badge'); if(b) b.remove();
    });
    
    log(`--- Round ${round} ---`, 'l-sys');
    updateUI();
    if(game.turn === 0) runAI();
}

// Rule 3: Bayesian Belief Update
function updateBelief() {
    // AI wants to guess game.hands[0] (Its own card, hidden)
    // It sees game.hands[1] (User's card, visible)
    // It observes User's actions in game.hist
    
    let userCard = game.hands[1].r; 
    let probs = new Float32Array(11).fill(1.0); // 1-10
    probs[userCard] = 0; // Impossible to have same card
    
    // Replay history to calculate likelihood
    let dummy = new State(chips[0], chips[1]); 
    // We only care about User's turns (Turn 1)
    
    for(let action of game.hist) {
        if(dummy.turn === 1) { // User's turn
            // User sees AI's card. User chose 'action'.
            // For each possible AI card 'c', what is P(action | User sees c)?
            for(let c=1; c<=10; c++) {
                if(c === userCard) continue;
                
                // Construct the Key the USER would see: "Opp:c|Seq:..."
                // User acts based on seeing 'c' on AI.
                let key = `Opp:${c}|Seq:${dummy.hist.join('')}`;
                let strat = solver.getNode(key).getAvgStrat(); // Use avg strategy
                
                // Valid actions check
                let valid = dummy.validActs();
                let stratProb = strat[action];
                
                // If action was valid, multiply probability
                if(valid.includes(action)) {
                     // Bayes: P(Hand|Action) ~ P(Action|Hand) * Prior
                     // Small heuristic: add small epsilon to avoid 0 lock
                     probs[c] *= (stratProb + 0.05); 
                }
            }
        }
        dummy.apply(action);
    }
    
    // Normalize & Visualize
    let sum = probs.reduce((a,b)=>a+b,0);
    let norm = probs.map(v => sum>0 ? v/sum : 0);
    
    let low=0, mid=0, high=0;
    for(let i=1; i<=5; i++) low+=norm[i];
    for(let i=6; i<=8; i++) mid+=norm[i];
    for(let i=9; i<=10; i++) high+=norm[i];
    
    document.getElementById('b-low').style.width = (low*100)+'%';
    document.getElementById('b-mid').style.width = (mid*100)+'%';
    document.getElementById('b-high').style.width = (high*100)+'%';
}

async function runAI() {
    updateUI();
    document.getElementById('ai-thought').style.display = 'block';
    
    updateBelief(); // Execute Real Math
    
    let txt = document.getElementById('ai-text');
    txt.innerText = "Reading your soul...";
    await new Promise(r => setTimeout(r, 1000 + Math.random()*1000));
    
    // AI Decision: Based on what it sees (User's Card)
    let key = `Opp:${game.hands[1].r}|Seq:${game.hist.join('')}`;
    let strat = solver.getNode(key).getAvgStrat();
    let valid = game.validActs();
    
    // Select Action
    let r = Math.random(), cum = 0, action = valid[0];
    let vSum = 0; valid.forEach(a => vSum += strat[a]);
    
    for(let a of valid) {
        let p = (vSum>0) ? strat[a]/vSum : 1/valid.length;
        cum += p;
        if(r <= cum) { action = a; break; }
    }
    
    log(`ðŸ¤– AI: ${ACT_TXT[action]}`, 'l-ai');
    game.apply(action);
    
    if(game.done) endRound();
    else updateUI();
}

function act(a) {
    if(game.turn!==1) return;
    log(`ðŸ‘¤ You: ${ACT_TXT[a]}`, 'l-user');
    game.apply(a);
    if(game.done) endRound();
    else runAI();
}

function endRound() {
    let p = game.payoff(1); // User payoff
    
    // Rule 1 & 4: Visuals
    updateUI(true);
    let aiCard = document.getElementById('c-ai');
    let myCard = document.getElementById('c-me');
    
    // Check for Penalty (Fold with 10)
    let last = game.hist[game.hist.length-1];
    if(last === ACT.FOLD) {
        let folder = game.turn; // turn remains on the one who folded? No, apply switches turn.
        // Wait, apply() logic: if fold, done=true, turn NOT switched.
        // So game.turn is the folder.
        if(game.hands[folder].r === 10) {
            let badge = document.createElement('div');
            badge.className = 'penalty-badge';
            badge.innerText = "-10 PENALTY";
            if(folder===0) aiCard.appendChild(badge); else myCard.appendChild(badge);
            log("ðŸš¨ 10-Holding Penalty Triggered!", "l-warn");
        }
    }

    if(p > 0) {
        log(`ðŸŽ‰ WIN (+${p})`, 'l-user');
        myCard.classList.add('winner'); aiCard.classList.add('loser');
    } else if(p < 0) {
        log(`ðŸ’€ LOSE (${p})`, 'l-ai');
        aiCard.classList.add('winner'); myCard.classList.add('loser');
    } else {
        log(`ðŸ¤ DRAW`, 'l-sys');
    }

    chips[1] += p; chips[0] -= p;
    setTimeout(startRound, 3000);
}
</script>
</body>
</html>

