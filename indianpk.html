<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Hold'em AI : Exploitative Master</title>
    <style>
        :root { --bg-color: #121212; --table-bg: #1b5e20; --card-bg: #eee; --accent: #ffd700; --danger: #ef5350; }
        body { font-family: 'Segoe UI', Roboto, sans-serif; background: var(--bg-color); color: #e0e0e0; margin: 0; display: flex; justify-content: center; min-height: 100vh; overflow: hidden; }
        
        .container { width: 100%; max-width: 480px; background: #1e1e1e; display: flex; flex-direction: column; height: 100vh; position: relative; box-shadow: 0 0 30px rgba(0,0,0,0.8); }

        /* Loading */
        #loading-screen { position: absolute; inset: 0; background: rgba(18,18,18,0.98); z-index: 100; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        .loader-bar-box { width: 70%; height: 6px; background: #333; border-radius: 3px; margin-top: 15px; overflow: hidden; }
        .loader-bar { height: 100%; width: 0%; background: linear-gradient(90deg, #ffd700, #ff8f00); transition: width 0.2s; }
        
        /* Header & Table */
        .header { padding: 15px; background: #263238; border-bottom: 2px solid #43a047; display: flex; justify-content: space-between; font-weight: bold; font-size: 1.1em; }
        .table { flex: 1; background: radial-gradient(circle at center, #2e7d32 0%, #1b5e20 80%); position: relative; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 20px; }
        
        /* Pot & Status */
        .pot-box { background: rgba(0,0,0,0.6); padding: 8px 25px; border-radius: 30px; border: 1px solid var(--accent); color: var(--accent); font-weight: bold; font-size: 1.4em; margin-bottom: 20px; box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
        .status-msg { color: #bdbdbd; font-style: italic; font-size: 0.9em; min-height: 1.2em; margin-bottom: 10px;}

        /* Players & Cards */
        .play-area { display: flex; width: 100%; justify-content: space-around; align-items: center; margin: 10px 0; }
        .player { text-align: center; position: relative; width: 40%; }
        .p-info { background: rgba(0,0,0,0.5); padding: 4px 10px; border-radius: 4px; font-size: 0.85em; margin-bottom: 8px; display: inline-block; }
        
        .card { 
            width: 75px; height: 110px; background: var(--card-bg); border-radius: 8px; margin: 0 auto;
            display: flex; justify-content: center; align-items: center; font-size: 2.2em; font-weight: bold;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5); position: relative; transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .card.red { color: #c62828; } .card.black { color: #212121; }
        .card.hidden { background: repeating-linear-gradient(45deg, #455a64, #455a64 10px, #37474f 10px, #37474f 20px); color: transparent; border: 2px solid #546e7a; }
        
        /* Visual Effects */
        .card.winner { transform: scale(1.15); box-shadow: 0 0 25px var(--accent); border: 3px solid var(--accent); z-index: 10; }
        .card.loser { opacity: 0.5; filter: grayscale(100%); transform: scale(0.9); }
        .penalty-badge { position: absolute; top: -12px; right: -12px; background: var(--danger); color: white; font-size: 0.7em; padding: 4px 8px; border-radius: 10px; font-weight: bold; border:2px solid white; animation: popIn 0.3s; z-index: 20; }

        /* AI Thought Bubble */
        .ai-brain { 
            width: 90%; background: rgba(255,255,255,0.92); color: #222; padding: 12px; 
            border-radius: 12px; margin-bottom: 20px; font-size: 0.85em; box-shadow: 0 10px 25px rgba(0,0,0,0.4);
            display: none; transform-origin: bottom; animation: floatUp 0.4s;
        }
        .bars { display: flex; height: 10px; border-radius: 5px; overflow: hidden; margin-top: 8px; background: #e0e0e0; }
        .bar-seg { height: 100%; transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1); }
        .b-low { background: #e53935; } .b-mid { background: #fdd835; } .b-high { background: #43a047; }
        .labels { display: flex; justify-content: space-between; font-size: 0.7em; color: #555; margin-top: 4px; font-weight: bold; }

        /* Controls */
        .controls { padding: 15px; background: #1e1e1e; display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; border-top: 1px solid #333; }
        button { padding: 14px 5px; border: none; border-radius: 8px; color: white; font-weight: bold; font-size: 0.95em; cursor: pointer; transition: transform 0.1s; box-shadow: 0 4px 0 rgba(0,0,0,0.2); }
        button:active { transform: scale(0.96) translateY(2px); box-shadow: 0 0 0; }
        button:disabled { opacity: 0.3; cursor: not-allowed; transform: none; box-shadow: none; filter: grayscale(100%); }
        
        .btn-fold { grid-column: span 1; background: #c62828; }
        .btn-check { grid-column: span 1; background: #2e7d32; }
        .btn-bet { background: #1565c0; }
        .btn-allin { grid-column: span 4; background: #6a1b9a; margin-top: 5px; background: linear-gradient(45deg, #7b1fa2, #4a148c); }

        /* Logs */
        .logs { height: 120px; overflow-y: auto; background: #111; padding: 10px; font-size: 0.8em; color: #bbb; border-top: 1px solid #333; scrollbar-width: thin; }
        .log-row { margin-bottom: 4px; border-bottom: 1px solid #222; padding-bottom: 2px; }
        .l-ai { color: #ffca28; } .l-user { color: #42a5f5; } .l-sys { color: #90a4ae; font-style: italic; } .l-warn { color: #ef5350; font-weight: bold; }

        @keyframes popIn { 0% {transform: scale(0);} 80% {transform: scale(1.2);} 100% {transform: scale(1);} }
        @keyframes floatUp { from {opacity:0; transform:translateY(15px);} to {opacity:1; transform:translateY(0);} }
    </style>
</head>
<body>

<div class="container">
    <div id="loading-screen">
        <div style="color:var(--accent); font-weight:bold; font-size:1.4em; text-shadow: 0 0 10px rgba(255,215,0,0.5);">Indian Hold'em AI</div>
        <div style="color:#aaa; font-size:0.9em; margin-bottom:20px;">Master Edition</div>
        <div class="loader-bar-box"><div class="loader-bar" id="load-bar"></div></div>
        <div style="color:#777; font-size:0.8em; margin-top:10px;">Training Neural Network (10k Hands)...</div>
    </div>

    <div class="header">
        <div>ü§ñ AI: <span id="s-ai">100</span></div>
        <div style="color:#888;">Round <span id="r-num">1</span></div>
        <div>üë§ You: <span id="s-me">100</span></div>
    </div>

    <div class="table">
        <div class="ai-brain" id="ai-thought">
            <div id="ai-text">Analyzing betting pattern...</div>
            <div style="margin-top:6px; font-weight:bold; color:#333; display:flex; justify-content:space-between;">
                <span>My Estimated Hand:</span>
                <span id="exploit-indicator" style="font-size:0.8em; color:#d32f2f; display:none;">(Adapting to You)</span>
            </div>
            <div class="bars">
                <div class="bar-seg b-low" id="b-low" style="width:33%"></div>
                <div class="bar-seg b-mid" id="b-mid" style="width:33%"></div>
                <div class="bar-seg b-high" id="b-high" style="width:33%"></div>
            </div>
            <div class="labels"><span>Weak (1-5)</span><span>Mid (6-8)</span><span>Strong (9-10)</span></div>
        </div>

        <div class="pot-box">POT: <span id="pot">2.0</span></div>

        <div class="play-area">
            <div class="player">
                <div class="p-info">AI (Bet: <span id="b-ai">1</span>)</div>
                <div class="card" id="c-ai">?</div>
            </div>
            <div class="player">
                <div class="p-info">You (Bet: <span id="b-me">1</span>)</div>
                <div class="card hidden" id="c-me">?</div>
            </div>
        </div>
        
        <div class="status-msg" id="status">Wait...</div>
    </div>

    <div class="controls">
        <button class="btn-fold" onclick="act(0)">Fold</button>
        <button class="btn-check" id="btn-chk" onclick="act(1)">Check</button>
        <button class="btn-bet" onclick="act(2)">Bet 33%</button>
        <button class="btn-bet" onclick="act(3)">Bet 75%</button>
        <button class="btn-allin" onclick="act(5)">ALL IN</button>
    </div>
    
    <div class="logs" id="log-box"></div>
</div>

<script>
/* --- 1. SETTINGS & SOUNDS --- */
const RANKS = [1,2,3,4,5,6,7,8,9,10];
const SUITS = ['s','h','d','c'];
const ACT = { FOLD:0, CHECK:1, BET_S:2, BET_L:3, BET_O:4, ALLIN:5 };
const ACT_TXT = ["Fold", "Check/Call", "Bet Small", "Bet Large", "Overbet", "All-In"];
const MULTS = { 2:0.33, 3:0.75, 4:1.5, 5:999 };

// ÏÇ¨Ïö¥Îìú ÌîåÎ†àÏù¥Ïñ¥ (ÌååÏùºÏù¥ ÏóÜÏñ¥ÎèÑ ÏóêÎü¨ Ïïà ÎÇòÎèÑÎ°ù Ï≤òÎ¶¨)
const sounds = {
    bet: new Audio('bet.mp3'), win: new Audio('win.mp3'),
    lose: new Audio('lose.mp3'), fold: new Audio('fold.mp3')
};
function playSound(k) {
    if(sounds[k]) {
        let s = sounds[k].cloneNode(); s.volume = 0.4;
        s.play().catch(()=>{}); // Î∏åÎùºÏö∞Ï†Ä Ï†ïÏ±ÖÏÉÅ Ïã§Ìå®Ïãú Î¨¥Ïãú
    }
}

/* --- 2. USER STATISTICS (EXPLOITATION DATA) --- */
const userStats = {
    totalHands: 0,
    foldCount: 0,
    getFoldRate: function() { return this.totalHands < 1 ? 0 : this.foldCount / this.totalHands; }
};

/* --- 3. SOLVER ENGINE (MCCFR) --- */
class Node {
    constructor(n) { this.r = new Float32Array(n); this.s = new Float32Array(n); }
    getStrat() {
        let sum = 0, res = this.r.map(v => { let x = Math.max(v,0); sum+=x; return x; });
        return sum > 0 ? res.map(v => v/sum) : res.map(() => 1/this.r.length);
    }
    getAvgStrat() {
        let sum = this.s.reduce((a,b)=>a+b,0);
        return sum > 0 ? this.s.map(v => v/sum) : this.s.map(() => 1/this.s.length);
    }
}

class Solver {
    constructor() { this.nodes = {}; }
    getNode(key) { if(!this.nodes[key]) this.nodes[key] = new Node(6); return this.nodes[key]; }
    
    // Pre-trained Îç∞Ïù¥ÌÑ∞ Î°úÎìúÏö© Î©îÏÑúÎìú
    load(jsonStr) {
        try {
            let d = JSON.parse(jsonStr);
            for(let k in d) {
                let n = new Node(6);
                n.r = new Float32Array(Object.values(d[k].r));
                n.s = new Float32Array(Object.values(d[k].s));
                this.nodes[k] = n;
            }
            return true;
        } catch(e) { console.error("Load Failed", e); return false; }
    }

    async train(iters, cb) {
        for(let i=0; i<iters; i+=100) {
            for(let j=0; j<100; j++) {
                let s0 = Math.random()<0.5 ? 100 : Math.floor(Math.random()*150)+20;
                let st = new State(s0, s0); st.turn = Math.random()<0.5?0:1;
                this.cfr(st, (i+j)%2, 1, 1);
            }
            if(cb) cb((i+100)/iters);
            await new Promise(r=>setTimeout(r,0));
        }
    }

    cfr(st, p, pr, w) {
        if(st.done) return st.payoff(p);
        let valid = st.validActs();
        if(valid.length===0) return 0;

        let key = `Opp:${st.hands[1-st.turn].r}|Seq:${st.hist.join('')}`;
        let node = this.getNode(key);
        let strat = node.getStrat();
        
        let probs = new Float32Array(6), sum = 0;
        valid.forEach(a => { probs[a] = strat[a]; sum += strat[a]; });
        if(sum>0) probs = probs.map(v=>v/sum); else valid.forEach(a=>probs[a]=1/valid.length);

        if(st.turn !== p) {
            let r=Math.random(), cum=0, a=valid[valid.length-1];
            for(let va of valid) { cum+=probs[va]; if(r<=cum){a=va; break;} }
            let next = st.clone(); next.apply(a);
            return this.cfr(next, p, pr, w);
        } else {
            let util = new Float32Array(6), nodeU = 0;
            valid.forEach(a => {
                let next = st.clone(); next.apply(a);
                util[a] = this.cfr(next, p, pr * probs[a], w);
                nodeU += probs[a] * util[a];
            });
            valid.forEach(a => {
                let r = util[a] - nodeU;
                node.r[a] += r * w; node.s[a] += (pr * probs[a]) * w;
            });
            return nodeU;
        }
    }
}

/* --- 4. GAME STATE (RULES) --- */
class State {
    constructor(s0, s1) {
        let deck = [];
        for(let r of RANKS) for(let s of SUITS) deck.push({r,s});
        for(let i=deck.length-1; i>0; i--) { let j=Math.floor(Math.random()*(i+1)); [deck[i],deck[j]]=[deck[j],deck[i]]; }
        
        this.hands = [deck.pop(), deck.pop()];
        this.stacks = [s0-1, s1-1];
        this.bets = [1, 1];
        this.pot = 2;
        this.contrib = [1, 1];
        this.hist = [];
        this.turn = 1; 
        this.done = false;
    }

    validActs() {
        let me = this.turn, opp = 1-me;
        if(this.stacks[me]<=0) return [ACT.FOLD, ACT.CHECK];
        let acts = [ACT.FOLD, ACT.CHECK];
        let diff = this.bets[opp] - this.bets[me];
        let target = this.pot + diff;
        
        for(let a of [2,3,5]) {
            if(a===ACT.ALLIN) { acts.push(a); continue; }
            let raise = target * MULTS[a];
            if(diff+raise < this.stacks[me] && raise >= 1) acts.push(a);
        }
        return acts;
    }

    apply(a) {
        this.hist.push(a);
        if(a===ACT.FOLD) { this.done = true; return; }
        
        let me = this.turn, opp = 1-me;
        let diff = this.bets[opp] - this.bets[me];
        let amt = (a===ACT.CHECK) ? Math.min(diff, this.stacks[me]) :
                  (a===ACT.ALLIN) ? this.stacks[me] :
                  Math.min(this.stacks[me], diff + (this.pot+diff)*MULTS[a]);
        
        this.stacks[me] -= amt; this.bets[me] += amt; this.contrib[me] += amt; this.pot += amt;
        if(a===ACT.CHECK && this.bets[0]===this.bets[1] && this.hist.length>=1) {
            if(this.hist.length>=2 || diff>0) this.done = true;
        }
        if(!this.done) this.turn = opp;
    }

    payoff(p) {
        let opp = 1-p;
        let last = this.hist[this.hist.length-1];
        
        // ‚òÖ [Rule Update] 10 Ìå®ÎÑêÌã∞ Î°úÏßÅ
        if(last === ACT.FOLD) {
            let folder = this.turn; // FoldÎ•º Ìïú ÏÇ¨Îûå
            let winner = 1-folder;
            let penalty = (this.hands[folder].r === 10) ? 10 : 0;
            
            if(p === winner) return (this.pot - this.contrib[p]) + penalty;
            else return -this.contrib[p] - penalty;
        }
        
        let r1 = this.hands[p].r, r2 = this.hands[opp].r;
        if(r1 > r2) return this.pot - this.contrib[p];
        if(r1 < r2) return -this.contrib[p];
        return 0; 
    }
    
    clone() {
        let s = new State(0,0);
        s.hands=[...this.hands]; s.stacks=[...this.stacks]; s.bets=[...this.bets];
        s.pot=this.pot; s.contrib=[...this.contrib]; s.hist=[...this.hist]; 
        s.turn=this.turn; s.done=this.done;
        return s;
    }
}

/* --- 5. UI & CONTROLLER --- */
const solver = new Solver();
let game = null, round = 0;
let chips = [100, 100]; // 0: AI, 1: User

// ‚òÖ Pre-trained DataÍ∞Ä ÏûàÎã§Î©¥ Ïó¨Í∏∞ÏÑú Î°úÎìú, ÏóÜÏúºÎ©¥ ÌïôÏäµ
const PRE_TRAINED = ""; // Ïó¨Í∏∞Ïóê JSON Î¨∏ÏûêÏó¥ ÎÑ£ÏúºÎ©¥ ÌïôÏäµ ÏÉùÎûµ Í∞ÄÎä•

window.onload = () => {
    if(PRE_TRAINED.length > 100 && solver.load(PRE_TRAINED)) {
        document.getElementById('loading-screen').style.display = 'none';
        startRound();
    } else {
        solver.train(30000, (pct) => {
            document.getElementById('load-bar').style.width = (pct*100)+'%';
        }).then(() => {
            document.getElementById('loading-screen').style.display = 'none';
            startRound();
        });
    }
};

function log(msg, cls) {
    let div = document.createElement('div');
    div.className = 'log-row '+cls; div.innerText = msg;
    let box = document.getElementById('log-box');
    box.appendChild(div); box.scrollTop = box.scrollHeight;
}

function updateUI(showHidden = false) {
    document.getElementById('s-ai').innerText = chips[0].toFixed(0);
    document.getElementById('s-me').innerText = chips[1].toFixed(0);
    document.getElementById('pot').innerText = game.pot.toFixed(0);
    document.getElementById('b-ai').innerText = game.bets[0].toFixed(0);
    document.getElementById('b-me').innerText = game.bets[1].toFixed(0);
    document.getElementById('r-num').innerText = round;

    let c0 = game.hands[0], c1 = game.hands[1];
    let el0 = document.getElementById('c-ai');
    el0.innerText = c0.r; el0.className = `card ${['h','d'].includes(c0.s)?'red':'black'}`;
    
    let el1 = document.getElementById('c-me');
    if(showHidden) {
        el1.innerText = c1.r; el1.className = `card ${['h','d'].includes(c1.s)?'red':'black'}`;
    } else {
        el1.innerText = "?"; el1.className = "card hidden";
    }

    let btns = document.querySelectorAll('.controls button');
    let valid = game.validActs();
    btns.forEach(b => b.disabled = true);
    
    if(!game.done && game.turn === 1) {
        let diff = game.bets[0] - game.bets[1];
        document.getElementById('btn-chk').innerText = diff===0 ? "Check" : `Call (${diff})`;
        if(valid.includes(0)) btns[0].disabled = false;
        if(valid.includes(1)) btns[1].disabled = false;
        if(valid.includes(2)) btns[2].disabled = false;
        if(valid.includes(3)) btns[3].disabled = false;
        if(valid.includes(5)) btns[4].disabled = false;
        document.getElementById('status').innerText = "Your Turn";
    } else {
        document.getElementById('status').innerText = game.done ? "Round Over" : "AI Thinking...";
    }
}

function startRound() {
    if(chips[0]<=0 || chips[1]<=0) { alert(chips[0]<=0?"You Win Game!":"You Lose Game!"); return; }
    
    userStats.totalHands++; // ÌÜµÍ≥ÑÏö© ÌåêÏàò Ï¶ùÍ∞Ä
    round++;
    game = new State(chips[0], chips[1]);
    document.getElementById('ai-thought').style.display = 'none';
    document.getElementById('exploit-indicator').style.display = 'none';
    
    document.querySelectorAll('.card').forEach(c => {
        c.classList.remove('winner', 'loser');
        let b = c.querySelector('.penalty-badge'); if(b) b.remove();
    });
    
    log(`--- Round ${round} ---`, 'l-sys');
    updateUI();
    if(game.turn === 0) runAI();
}

function updateBelief() {
    let userCard = game.hands[1].r; 
    let probs = new Float32Array(11).fill(1.0); 
    probs[userCard] = 0; 
    
    let dummy = new State(chips[0], chips[1]); 
    for(let action of game.hist) {
        if(dummy.turn === 1) { 
            for(let c=1; c<=10; c++) {
                if(c === userCard) continue;
                let key = `Opp:${c}|Seq:${dummy.hist.join('')}`;
                let strat = solver.getNode(key).getAvgStrat(); 
                let valid = dummy.validActs();
                if(valid.includes(action)) probs[c] *= (strat[action] + 0.05); 
            }
        }
        dummy.apply(action);
    }
    
    let sum = probs.reduce((a,b)=>a+b,0);
    let norm = probs.map(v => sum>0 ? v/sum : 0);
    
    let low=0, mid=0, high=0;
    for(let i=1; i<=5; i++) low+=norm[i];
    for(let i=6; i<=8; i++) mid+=norm[i];
    for(let i=9; i<=10; i++) high+=norm[i];
    
    document.getElementById('b-low').style.width = (low*100)+'%';
    document.getElementById('b-mid').style.width = (mid*100)+'%';
    document.getElementById('b-high').style.width = (high*100)+'%';
}

async function runAI() {
    updateUI();
    document.getElementById('ai-thought').style.display = 'block';
    
    updateBelief(); // Î¶¨Ïñº Î≤†Ïù¥ÏßÄÏïà ÏóÖÎç∞Ïù¥Ìä∏
    
    let txt = document.getElementById('ai-text');
    txt.innerText = "Analyzing your habits...";
    await new Promise(r => setTimeout(r, 800 + Math.random()*1200));
    
    let key = `Opp:${game.hands[1].r}|Seq:${game.hist.join('')}`;
    let strat = solver.getNode(key).getAvgStrat();
    let valid = game.validActs();
    
    // ‚òÖ [CORE] Smooth Exploitative Logic (Î∂ÄÎìúÎü¨Ïö¥ Ï∞©Ï∑®)
    if (userStats.totalHands >= 10) {
        const NASH_FOLD = 0.4; // Í∏∞Ï§Ä Ìè¥ÎìúÏú®
        const SENSITIVITY = 1.2; // Î≥ÄÌôî ÎØºÍ∞êÎèÑ
        
        let userRate = userStats.getFoldRate();
        let diff = userRate - NASH_FOLD; 
        
        // Multiplier Í≥ÑÏÇ∞: Ï´ÑÎ≥¥(ÏñëÏàò) -> Î∞∞ÌåÖÏ¶ùÍ∞Ä, ÏΩúÎßåÌï®(ÏùåÏàò) -> Î∞∞ÌåÖÍ∞êÏÜå
        let multiplier = 1.0 + (diff * SENSITIVITY);
        
        // Î∞∞ÌåÖ Í≥ÑÏó¥ Ïï°ÏÖò ÌôïÎ•† Ï°∞Ïûë
        let adjusted = false;
        [ACT.BET_S, ACT.BET_L, ACT.BET_O].forEach(action => {
            if (valid.includes(action) && strat[action] > 0.01) {
                strat[action] = Math.max(0, strat[action] * multiplier);
                adjusted = true;
            }
        });
        
        // ÌôïÎ•† Ïû¨Ï†ïÍ∑úÌôî
        if(adjusted) {
            let sum = 0; valid.forEach(a => sum += strat[a]);
            if(sum > 0) valid.forEach(a => strat[a] /= sum);
            
            // ÏãúÍ∞ÅÏ†Å ÌîºÎìúÎ∞± (ÎîîÎ≤ÑÍπÖ Í≤∏Ïö©)
            if(Math.abs(diff) > 0.15) document.getElementById('exploit-indicator').style.display = 'inline';
        }
    }
    
    // Action Selection
    let r = Math.random(), cum = 0, action = valid[0];
    let vSum = 0; valid.forEach(a => vSum += strat[a]);
    
    for(let a of valid) {
        let p = (vSum>0) ? strat[a]/vSum : 1/valid.length;
        cum += p;
        if(r <= cum) { action = a; break; }
    }
    
    log(`ü§ñ AI: ${ACT_TXT[action]}`, 'l-ai');
    if(action >= ACT.BET_S) playSound('bet'); else if(action===ACT.CHECK) playSound('bet');
    
    game.apply(action);
    if(game.done) endRound();
    else updateUI();
}

function act(a) {
    if(game.turn!==1) return;
    if(a===ACT.FOLD) { userStats.foldCount++; playSound('fold'); }
    else playSound('bet');
    
    log(`üë§ You: ${ACT_TXT[a]}`, 'l-user');
    game.apply(a);
    if(game.done) endRound();
    else runAI();
}

function endRound() {
    let p = game.payoff(1); 
    updateUI(true); // Ïπ¥Îìú Ïò§Ìîà
    
    let aiCard = document.getElementById('c-ai');
    let myCard = document.getElementById('c-me');
    
    // 10 Penalty Badge Check
    let last = game.hist[game.hist.length-1];
    if(last === ACT.FOLD) {
        let folder = game.turn; 
        if(game.hands[folder].r === 10) {
            let badge = document.createElement('div');
            badge.className = 'penalty-badge'; badge.innerText = "-10 PENALTY";
            if(folder===0) aiCard.appendChild(badge); else myCard.appendChild(badge);
            log("üö® 10-Holding Penalty!", "l-warn");
        }
    }

    if(p > 0) {
        log(`üéâ WIN (+${p})`, 'l-user'); playSound('win');
        myCard.classList.add('winner'); aiCard.classList.add('loser');
    } else if(p < 0) {
        log(`üíÄ LOSE (${p})`, 'l-ai'); playSound('lose');
        aiCard.classList.add('winner'); myCard.classList.add('loser');
    } else {
        log(`ü§ù DRAW`, 'l-sys');
    }

    chips[1] += p; chips[0] -= p;
    setTimeout(startRound, 2500);
}
</script>
</body>
</html>


