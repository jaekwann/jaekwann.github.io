<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Hold'em : Advanced AI</title>
    <style>
        :root { --bg-color: #121212; --table-bg: #1b5e20; --card-bg: #eee; --accent: #ffd700; --danger: #ef5350; --btn-primary: #1565c0; }
        body { font-family: 'Segoe UI', Roboto, sans-serif; background: var(--bg-color); color: #e0e0e0; margin: 0; display: flex; justify-content: center; min-height: 100vh; overflow: hidden; }
        
        .container { width: 100%; max-width: 480px; background: #1e1e1e; display: flex; flex-direction: column; height: 100vh; position: relative; box-shadow: 0 0 30px rgba(0,0,0,0.8); }

        /* Loading */
        #loading-screen { position: absolute; inset: 0; background: rgba(18,18,18,0.98); z-index: 100; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        .loader-bar-box { width: 70%; height: 6px; background: #333; border-radius: 3px; margin-top: 15px; overflow: hidden; }
        .loader-bar { height: 100%; width: 0%; background: linear-gradient(90deg, #ffd700, #ff8f00); transition: width 0.2s; }
        
        /* Header */
        .header { padding: 15px; background: #263238; border-bottom: 2px solid #43a047; display: flex; justify-content: space-between; align-items: center; font-weight: bold; font-size: 1.1em; }
        .deck-info { background: #000; padding: 5px 12px; border-radius: 15px; font-size: 0.85em; color: var(--accent); border: 1px solid #444; box-shadow: inset 0 0 5px rgba(0,0,0,0.5); }

        /* Table */
        .table { flex: 1; background: radial-gradient(circle at center, #2e7d32 0%, #1b5e20 80%); position: relative; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 20px; }
        
        /* Pot & Status */
        .pot-box { background: rgba(0,0,0,0.6); padding: 8px 25px; border-radius: 30px; border: 1px solid var(--accent); color: var(--accent); font-weight: bold; font-size: 1.4em; margin-bottom: 20px; box-shadow: 0 4px 10px rgba(0,0,0,0.3); transition: all 0.3s; }
        .pot-box.carried { box-shadow: 0 0 20px #ffd700; border: 2px solid #fff; background: rgba(255, 215, 0, 0.2); }
        .status-msg { color: #bdbdbd; font-style: italic; font-size: 0.9em; min-height: 1.2em; margin-bottom: 10px; text-align: center; }

        /* Players & Cards */
        .play-area { display: flex; width: 100%; justify-content: space-around; align-items: center; margin: 10px 0; }
        .player { text-align: center; position: relative; width: 40%; }
        .p-info { background: rgba(0,0,0,0.5); padding: 4px 10px; border-radius: 4px; font-size: 0.85em; margin-bottom: 8px; display: inline-block; }
        
        .card { 
            width: 75px; height: 110px; background: var(--card-bg); border-radius: 8px; margin: 0 auto;
            display: flex; justify-content: center; align-items: center; font-size: 2.2em; font-weight: bold;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5); position: relative; transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .card.red { color: #c62828; } .card.black { color: #212121; }
        .card.hidden { background: repeating-linear-gradient(45deg, #455a64, #455a64 10px, #37474f 10px, #37474f 20px); color: transparent; border: 2px solid #546e7a; }
        
        .badge { position: absolute; top: -12px; right: -12px; color: white; font-size: 0.6em; padding: 4px 6px; border-radius: 8px; font-weight: bold; border:2px solid white; animation: popIn 0.3s; z-index: 20; white-space: nowrap; box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
        .bg-pen { background: var(--danger); }
        .bg-rev { background: #7b1fa2; }
        .card.winner { transform: scale(1.15); box-shadow: 0 0 25px var(--accent); border: 3px solid var(--accent); z-index: 10; }
        .card.loser { opacity: 0.5; filter: grayscale(100%); transform: scale(0.9); }

        /* AI Thought */
        .ai-brain { 
            width: 90%; background: rgba(255,255,255,0.92); color: #222; padding: 12px; 
            border-radius: 12px; margin-bottom: 20px; font-size: 0.85em; box-shadow: 0 10px 25px rgba(0,0,0,0.4);
            display: none; transform-origin: bottom; animation: floatUp 0.4s;
        }

        /* Controls */
        .controls { padding: 15px; background: #1e1e1e; display: flex; flex-direction: column; gap: 10px; border-top: 1px solid #333; }
        
        .btn-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; }
        
        .slider-box { display: flex; align-items: center; gap: 10px; background: #111; padding: 8px; border-radius: 8px; border: 1px solid #333; }
        input[type=range] { flex: 1; accent-color: var(--accent); cursor: pointer; }
        
        button { padding: 12px 2px; border: none; border-radius: 6px; color: white; font-weight: bold; font-size: 0.9em; cursor: pointer; transition: transform 0.1s; box-shadow: 0 3px 0 rgba(0,0,0,0.3); }
        button:active { transform: scale(0.96) translateY(2px); box-shadow: 0 0 0; }
        button:disabled { opacity: 0.3; cursor: not-allowed; transform: none; box-shadow: none; filter: grayscale(100%); }
        
        .btn-fold { background: #c62828; }
        .btn-check { background: #2e7d32; }
        .btn-half { background: #1565c0; }
        .btn-pot { background: #0277bd; }
        .btn-allin { background: #6a1b9a; grid-column: span 1; }
        
        .btn-custom { width: 90px; background: var(--accent); color: #000; font-size: 0.85em; padding: 8px; }

        /* Logs */
        .logs { height: 100px; overflow-y: auto; background: #000; padding: 10px; font-size: 0.8em; color: #bbb; border-top: 1px solid #333; scrollbar-width: thin; }
        .log-row { margin-bottom: 4px; border-bottom: 1px solid #222; padding-bottom: 2px; }
        .l-ai { color: #ffca28; } .l-user { color: #42a5f5; } .l-sys { color: #90a4ae; font-style: italic; } .l-warn { color: #ef5350; font-weight: bold; } .l-deck { color: #00e676; }

        @keyframes popIn { 0% {transform: scale(0);} 80% {transform: scale(1.2);} 100% {transform: scale(1);} }
        @keyframes floatUp { from {opacity:0; transform:translateY(15px);} to {opacity:1; transform:translateY(0);} }
    </style>
</head>
<body>

<div class="container">
    <div id="loading-screen">
        <div style="color:var(--accent); font-weight:bold; font-size:1.4em; text-shadow: 0 0 10px rgba(255,215,0,0.5);">Indian Hold'em</div>
        <div style="color:#aaa; font-size:0.9em; margin-bottom:20px;">Perfect AI + Hero Call</div>
        <div class="loader-bar-box"><div class="loader-bar" id="load-bar"></div></div>
        <div style="color:#777; font-size:0.8em; margin-top:10px;">Neural Training...</div>
    </div>

    <div class="header">
        <div>ğŸ¤– <span id="s-ai">100</span></div>
        <div class="deck-info" id="deck-ui">Deck: 20</div>
        <div>ğŸ‘¤ <span id="s-me">100</span></div>
    </div>

    <div class="table">
        <div class="ai-brain" id="ai-thought">
            <div id="ai-text">Thinking...</div>
            <div style="height:4px; background:#ddd; margin-top:4px; border-radius:2px; overflow:hidden;">
                <div id="win-rate-bar" style="width:50%; height:100%; background:#43a047;"></div>
            </div>
            <div id="ai-risk" style="font-size:0.75em; color:#ef5350; margin-top:2px; display:none;"></div>
            <div id="ai-hero" style="font-size:0.75em; color:#29b6f6; margin-top:2px; display:none;"></div>
        </div>

        <div class="pot-box" id="pot-box">POT: <span id="pot">2.0</span></div>

        <div class="play-area">
            <div class="player">
                <div class="p-info">AI (Bet: <span id="b-ai">1</span>)</div>
                <div class="card" id="c-ai">?</div>
            </div>
            <div class="player">
                <div class="p-info">You (Bet: <span id="b-me">1</span>)</div>
                <div class="card hidden" id="c-me">?</div>
            </div>
        </div>
        
        <div class="status-msg" id="status">Wait...</div>
    </div>

    <div class="controls">
        <div class="slider-box">
            <input type="range" id="bet-slider" min="1" max="100" value="1" oninput="updateSliderBtn()">
            <button class="btn-custom" id="btn-custom" onclick="actCustom()">Bet 1</button>
        </div>
        
        <div class="btn-grid">
            <button class="btn-fold" onclick="act(0)">Fold</button>
            <button class="btn-check" id="btn-chk" onclick="act(1)">Check</button>
            <button class="btn-half" onclick="act(2)">50%</button>
            <button class="btn-pot" onclick="act(3)">Pot</button>
        </div>
        <div class="btn-grid">
             <button class="btn-allin" onclick="act(5)" style="grid-column: span 4; background: linear-gradient(45deg, #7b1fa2, #4a148c);">ALL IN</button>
        </div>
    </div>
    
    <div class="logs" id="log-box"></div>
</div>

<script>
/* --- 1. SETTINGS --- */
const RANKS = [1,2,3,4,5,6,7,8,9,10];
const ACT = { FOLD:0, CHECK:1, BET_H:2, BET_P:3, BET_O:4, ALLIN:5 };
const ACT_TXT = ["Fold", "Check/Call", "Bet Half", "Bet Pot", "Overbet", "All-In"];
const MULTS = { 2:0.5, 3:1.0, 4:1.5, 5:999 }; 

/* --- 2. SHOE SYSTEM --- */
const shoe = {
    cards: [], max: 20,
    init: function() {
        this.cards = [];
        for(let i=0; i<2; i++) for(let r=1; r<=10; r++) this.cards.push({r, s: i===0?'s':'h'});
        for(let i=this.cards.length-1; i>0; i--) { let j=Math.floor(Math.random()*(i+1)); [this.cards[i],this.cards[j]]=[this.cards[j],this.cards[i]]; }
        log("ğŸ”„ Deck Reshuffled", "l-deck"); updateDeckUI();
    },
    draw: function() {
        if(this.cards.length < 2) this.init();
        let c = this.cards.pop(); updateDeckUI(); return c;
    }
};

function updateDeckUI() {
    let el = document.getElementById('deck-ui');
    el.innerText = `Deck: ${shoe.cards.length}/${shoe.max}`;
    el.style.borderColor = shoe.cards.length <= 6 ? "#ef5350" : "#444";
}

/* --- 3. SOLVER (AI) --- */
class Node {
    constructor(n) { this.r = new Float32Array(n); this.s = new Float32Array(n); }
    getStrat() {
        let sum = 0, res = this.r.map(v => { let x = Math.max(v,0); sum+=x; return x; });
        return sum > 0 ? res.map(v => v/sum) : res.map(() => 1/this.r.length);
    }
    getAvgStrat() {
        let sum = this.s.reduce((a,b)=>a+b,0);
        return sum > 0 ? this.s.map(v => v/sum) : this.s.map(() => 1/this.s.length);
    }
}

class Solver {
    constructor() { this.nodes = {}; }
    getNode(key) { if(!this.nodes[key]) this.nodes[key] = new Node(6); return this.nodes[key]; }
    
    async train(iters, cb) {
        for(let i=0; i<iters; i+=100) {
            for(let j=0; j<100; j++) {
                let s0 = Math.random()<0.5 ? 100 : Math.floor(Math.random()*150)+20;
                let st = new State(s0, s0); st.turn = Math.random()<0.5?0:1;
                this.cfr(st, (i+j)%2, 1, 1);
            }
            if(cb) cb((i+100)/iters);
            await new Promise(r=>setTimeout(r,0));
        }
    }

    cfr(st, p, pr, w) {
        if(st.done) return st.payoff(p);
        let valid = st.validActs();
        if(valid.length===0) return 0;
        let key = `Opp:${st.hands[1-st.turn].r}|Seq:${st.hist.join('')}`;
        let node = this.getNode(key);
        let strat = node.getStrat();
        let probs = new Float32Array(6), sum = 0;
        valid.forEach(a => { probs[a] = strat[a]; sum += strat[a]; });
        if(sum>0) probs = probs.map(v=>v/sum); else valid.forEach(a=>probs[a]=1/valid.length);

        if(st.turn !== p) {
            let r=Math.random(), cum=0, a=valid[valid.length-1];
            for(let va of valid) { cum+=probs[va]; if(r<=cum){a=va; break;} }
            let next = st.clone(); next.apply(a);
            return this.cfr(next, p, pr, w);
        } else {
            let util = new Float32Array(6), nodeU = 0;
            valid.forEach(a => {
                let next = st.clone(); next.apply(a);
                util[a] = this.cfr(next, p, pr * probs[a], w);
                nodeU += probs[a] * util[a];
            });
            valid.forEach(a => {
                let r = util[a] - nodeU;
                node.r[a] += r * w; node.s[a] += (pr * probs[a]) * w;
            });
            return nodeU;
        }
    }
}

/* --- 4. GAME STATE --- */
/* --- 4. GAME STATE (ìˆ˜ì •ë¨) --- */
class State {
    constructor(s0, s1, h1=null, h2=null) {
        if(h1 && h2) this.hands = [h1, h2];
        else { let d=[]; for(let r of RANKS)d.push({r,s:'x'}); this.hands=[d[Math.floor(Math.random()*10)],d[Math.floor(Math.random()*10)]]; }
        this.stacks = [s0-1, s1-1];
        this.bets = [1, 1];
        
        let carried = window.carriedPot || 0;
        this.pot = 2 + carried;
        this.wasCarried = carried > 0;
        window.carriedPot = 0; 
        
        this.contrib = [1, 1];
        this.hist = [];
        this.turn = 1; this.done = false;
    }

    validActs() {
        let me = this.turn, opp = 1-me;
        if(this.stacks[me]<=0) return [ACT.FOLD, ACT.CHECK];
        let acts = [ACT.FOLD, ACT.CHECK];
        let diff = this.bets[opp] - this.bets[me];
        let target = this.pot + diff;
        for(let a of [2,3,5]) { 
            if(a===ACT.ALLIN) { acts.push(a); continue; }
            let raise = target * MULTS[a];
            if(diff+raise < this.stacks[me] && raise >= 1) acts.push(a);
        }
        return acts;
    }

    apply(a, customAmt = -1) {
        this.hist.push(a);
        if(a===ACT.FOLD) { this.done = true; return; }
        
        let me = this.turn, opp = 1-me;
        let diff = this.bets[opp] - this.bets[me];
        let amt = 0;

        // [FIX 1] ì˜¬ì¸ ë° ë² íŒ… ê¸ˆì•¡ ê³„ì‚° ë¡œì§ ìˆ˜ì • (ìƒëŒ€ ìŠ¤íƒì— ë§ì¶¤)
        if (customAmt > 0) {
            // ì»¤ìŠ¤í…€ ë² íŒ…ì´ë¼ë„ ìƒëŒ€ë°©ì˜ ì „ì¬ì‚°ë³´ë‹¤ ë§ì´ ê±¸ í•„ìš”ëŠ” ì—†ìŒ (ìœ íš¨ ìŠ¤íƒ ì ìš©)
            let effectiveMax = this.stacks[opp] + diff; 
            // ë‚´ ìŠ¤íƒ, ì»¤ìŠ¤í…€ ê¸ˆì•¡, ê·¸ë¦¬ê³  (ìƒëŒ€ ìŠ¤íƒ + ì°¨ì•¡) ì¤‘ ê°€ì¥ ì‘ì€ ê°’
            amt = Math.min(this.stacks[me], customAmt, effectiveMax); 
        } else {
            if (a === ACT.CHECK) {
                amt = Math.min(diff, this.stacks[me]);
            } else if (a === ACT.ALLIN) {
                // [FIX 2] ë‚´ ì˜¬ì¸ ê¸ˆì•¡ì€ 'ë‚´ ì „ì¬ì‚°'ê³¼ 'ìƒëŒ€ë°©ì˜ ì´ ìì‚°(ìŠ¤íƒ+ë² íŒ…)' ì¤‘ ì‘ì€ ìª½ìœ¼ë¡œ ì œí•œ
                let myTotal = this.stacks[me] + this.bets[me];
                let oppTotal = this.stacks[opp] + this.bets[opp];
                let effectiveStack = Math.min(myTotal, oppTotal);
                amt = effectiveStack - this.bets[me];
            } else {
                // í•˜í”„/íŒŸ ë² íŒ…
                amt = Math.min(this.stacks[me], diff + Math.floor((this.pot+diff)*MULTS[a]));
            }
        }
        
        // ì¹© ì´ë™ ì²˜ë¦¬
        this.stacks[me] -= amt; 
        this.bets[me] += amt; 
        this.contrib[me] += amt; 
        this.pot += amt;
        
        // [FIX 3] ì¢…ë£Œ ì¡°ê±´ ê°•í™”
        // 1. ìƒëŒ€ê°€ ì˜¬ì¸ ìƒíƒœ(ìŠ¤íƒ 0)ì´ê³ , ë‚´ê°€ ê·¸ ê¸ˆì•¡ì„ ì»¤ë²„í–ˆìœ¼ë©´(ê°™ê±°ë‚˜ ë§ì´ ëƒˆìœ¼ë©´) ì¢…ë£Œ
        if (this.stacks[opp] <= 0 && this.bets[me] >= this.bets[opp]) {
            this.done = true;
        }
        // 2. ë‚´ê°€ ì˜¬ì¸ ìƒíƒœì´ê³ , ìƒëŒ€ê°€ ë‚´ ê¸ˆì•¡ì„ ì»¤ë²„í–ˆìœ¼ë©´ ì¢…ë£Œ
        else if (this.stacks[me] <= 0 && this.bets[opp] >= this.bets[me]) {
            this.done = true;
        }
        // 3. ê¸°ì¡´ ë¡œì§: ë² íŒ…ì•¡ì´ ê°™ê³  ì•¡ì…˜ì´ ì˜¤ê°”ìœ¼ë©´ ì¢…ë£Œ
        else if(this.bets[0]===this.bets[1] && this.hist.length>=1) {
            if(a===ACT.CHECK || a===ACT.FOLD || diff > 0 || (customAmt === diff)) { 
                 if(this.hist.length>=2 || diff>0) this.done = true; 
            }
        }

        if(!this.done) this.turn = opp;
    }
    
    // ... payoff, clone ë©”ì„œë“œëŠ” ê¸°ì¡´ê³¼ ë™ì¼ ...
    payoff(p) {
        let opp = 1-p;
        let last = this.hist[this.hist.length-1];
        if(last === ACT.FOLD) {
            let folder = this.turn;
            let penalty = (this.hands[folder].r === 10) ? 10 : 0;
            return (p === (1-folder) ? (this.pot-this.contrib[p]) + penalty : -this.contrib[p] - penalty);
        }
        let r1=this.hands[p].r, r2=this.hands[opp].r;
        if(r1===1 && r2===10) return this.pot-this.contrib[p];
        if(r1===10 && r2===1) return -this.contrib[p];
        if(r1>r2) return this.pot-this.contrib[p];
        if(r1<r2) return -this.contrib[p];
        return 0;
    }
    
    clone() {
        let s = new State(0,0);
        s.hands = this.hands.map(h => ({...h})); 
        s.stacks=[...this.stacks]; s.bets=[...this.bets];
        s.pot=this.pot; s.contrib=[...this.contrib]; s.hist=[...this.hist]; 
        s.turn=this.turn; s.done=this.done;
        return s;
    }
}

/* --- 5. CONTROLLER --- */
const solver = new Solver();
// [UPDATE] ìœ ì € ì„±í–¥ ë¶„ì„ ê°•í™” (Bluff Detection)
const userStats = { 
    totalHands:0, foldCount:0, 
    bluffOpportunities: 0, // ë¸”ëŸ¬í•‘ì´ ê°€ëŠ¥í•œ ìƒí™©(ì‡¼ë‹¤ìš´)
    bluffsDetected: 0,     // ì‹¤ì œ ë¸”ëŸ¬í•‘ ê°ì§€ íšŸìˆ˜
    getFoldRate: function(){return this.totalHands<1?0:this.foldCount/this.totalHands;},
    getBluffRate: function(){return this.bluffOpportunities<1?0:this.bluffsDetected/this.bluffOpportunities;}
};

let game = null, round = 0, chips = [100, 100];
window.carriedPot = 0;

window.onload = () => {
    shoe.init();
    solver.train(50000, (pct) => { document.getElementById('load-bar').style.width = (pct*100)+'%'; })
          .then(() => { document.getElementById('loading-screen').style.display = 'none'; startRound(); });
};

function log(msg, cls) {
    let div = document.createElement('div'); div.className='log-row '+cls; div.innerText=msg;
    let box = document.getElementById('log-box'); box.appendChild(div); box.scrollTop = box.scrollHeight;
}

function updateUI(showHidden = false) {
    document.getElementById('s-ai').innerText = chips[0].toFixed(0);
    document.getElementById('s-me').innerText = chips[1].toFixed(0);
    
    // [UPDATE] Carried Pot ì‹œê°í™”
    let potEl = document.getElementById('pot');
    let potBox = document.getElementById('pot-box');
    potEl.innerText = game.pot.toFixed(0);
    if(game.wasCarried && game.pot > 0) {
         potEl.innerText += " (Carried)";
         potBox.classList.add('carried');
    } else {
         potBox.classList.remove('carried');
    }

    document.getElementById('b-ai').innerText = game.bets[0].toFixed(0);
    document.getElementById('b-me').innerText = game.bets[1].toFixed(0);
    
    let c0=game.hands[0], c1=game.hands[1];
    let el0=document.getElementById('c-ai'); el0.innerText=c0.r; el0.className=`card ${['h','d'].includes(c0.s)?'red':'black'}`;
    
    let el1=document.getElementById('c-me'); 
    if(showHidden) { el1.innerText=c1.r; el1.className=`card ${['h','d'].includes(c1.s)?'red':'black'}`; }
    else { el1.innerText="?"; el1.className="card hidden"; }

    let btns = document.querySelectorAll('.controls button');
    let slider = document.getElementById('bet-slider');
    let valid = game.validActs();
    
    btns.forEach(b => b.disabled = true);
    slider.disabled = true;

    if(!game.done && game.turn === 1) {
        let diff = game.bets[0] - game.bets[1];
        document.getElementById('btn-chk').innerText = diff===0 ? "Check" : `Call (${diff})`;
        valid.forEach(v => { 
            let idx = (v===5) ? 5 : (v===0?0: (v===1?1: (v===2?2: (v===3?3: -1))));
            if(idx>=0 && btns[idx]) btns[idx].disabled = false;
        });
        
        let minBet = diff > 0 ? diff : 1;
        let maxBet = game.stacks[1];
        if(maxBet >= minBet) {
            slider.disabled = false;
            slider.min = minBet;
            slider.max = maxBet;
            slider.value = minBet;
            updateSliderBtn();
            document.getElementById('btn-custom').disabled = false;
        }
        document.getElementById('status').innerText = "Your Turn";
    } else {
        document.getElementById('status').innerText = game.done ? "Round Over" : "AI Thinking...";
    }
}

function updateSliderBtn() {
    let val = document.getElementById('bet-slider').value;
    let diff = game.bets[0] - game.bets[1];
    let txt = (parseInt(val) === diff && diff > 0) ? `Call ${val}` : `Bet ${val}`;
    document.getElementById('btn-custom').innerText = txt;
}

function startRound() {
    if(chips[0]<=0 || chips[1]<=0) { alert(chips[0]<=0?"You Win Game!":"You Lose Game!"); return; }
    userStats.totalHands++; round++;
    let h1 = shoe.draw(), h2 = shoe.draw();
    game = new State(chips[0], chips[1], h1, h2);
    
    document.getElementById('ai-thought').style.display = 'none';
    document.getElementById('ai-risk').style.display = 'none';
    document.getElementById('ai-hero').style.display = 'none';
    document.querySelectorAll('.card').forEach(c => { c.classList.remove('winner','loser'); let b=c.querySelector('.badge'); if(b)b.remove(); });
    
    log(`--- Round ${round} ---`, 'l-sys');
    updateUI();
    if(game.turn === 0) runAI();
}

function analyzeHand(oppRank, unknownCards) {
    let wins=0, total=0, tenCount=0;
    for(let c of unknownCards) {
        let myPotentialRank = c.r;
        total++;
        if(myPotentialRank === 10) tenCount++;
        
        if(myPotentialRank===1 && oppRank===10) { wins++; continue; }
        if(myPotentialRank===10 && oppRank===1) continue;
        if(myPotentialRank > oppRank) wins++;
        else if(myPotentialRank === oppRank) wins+=0.5;
    }
    return {
        equity: total===0 ? 0.5 : wins/total,
        probTen: total===0 ? 0 : tenCount/total
    };
}

async function runAI() {
    updateUI(); document.getElementById('ai-thought').style.display='block';
    
    let playerCardRank = game.hands[1].r; 
    let unknownPool = [...shoe.cards, game.hands[0]]; 
    
    let analysis = analyzeHand(playerCardRank, unknownPool);
    let equity = analysis.equity;
    let probTen = analysis.probTen;
    
    document.getElementById('ai-text').innerText = `Win Rate: ${(equity*100).toFixed(0)}% (Pot: ${game.pot})`;
    let bar = document.getElementById('win-rate-bar');
    bar.style.width=(equity*100)+'%';
    bar.style.background = equity>0.6?'#43a047':(equity<0.4?'#e53935':'#fdd835');

    let riskEl = document.getElementById('ai-risk');
    let heroEl = document.getElementById('ai-hero');
    
    // UI í‘œì‹œ ë¡œì§
    if(probTen > 0.1) {
        riskEl.style.display = 'block';
        riskEl.innerText = `âš ï¸ 10-Risk: ${(probTen*100).toFixed(0)}%`;
    } else riskEl.style.display = 'none';
    
    heroEl.style.display = 'none';

    await new Promise(r=>setTimeout(r, 600+Math.random()*800));

    let key = `Opp:${game.hands[1].r}|Seq:${game.hist.join('')}`;
    let strat = solver.getNode(key).getAvgStrat();
    let valid = game.validActs();

    /* --- [Logic Update] Pot Odds & Aggression Check --- */

// 1. Pot Odds ê³„ì‚° (ì •í™•í•¨)
// diffëŠ” ìƒëŒ€ê°€ ë” ê±´ ê¸ˆì•¡. ì¦‰ ë‚´ê°€ ì½œ(Call)í•´ì•¼ í•˜ëŠ” ë¹„ìš©.
let callCost = game.bets[1] - game.bets[0]; 
// ìŠ¹ë¥ ì´ ì´ ê°’ë³´ë‹¤ ë‚®ìœ¼ë©´ ìˆ˜í•™ì ìœ¼ë¡œ ì†í•´ (Break-even Point)
let requiredEquity = callCost > 0 ? callCost / (game.pot + callCost) : 0;

// 2. Pot Oddsê°€ ë‚˜ì  ë•Œì˜ ë°©ì–´ ë¡œì§ (Deep Stack ë³´í˜¸)
if (requiredEquity > 0.35) { // ì´ê¸°ê¸° ìœ„í•´ 35% ì´ìƒì˜ ìŠ¹ë¥ ì´ í•„ìš”í•  ë§Œí¼ ë¹„ìŒ€ ë•Œ
    // ë‹¨, 1(í˜ëª…), 9, 10(ìµœê°•)ì€ ì ˆëŒ€ ì£½ì§€ ì•ŠìŒ (Whitelist)
    if (![1, 9, 10].includes(game.hands[0].r)) {
        strat[ACT.FOLD] *= 2.0; // í´ë“œ í™•ë¥  2ë°° ì¦ê°€ (ë¬´ë¦¬í•˜ì§€ ì•ŠìŒ)
    }
}

// 3. ìƒëŒ€ ê³µê²©ì„± íŒ¨í„´ ê°ì§€ (Safe Logic)
// í˜„ì¬ AI í„´ì´ë¯€ë¡œ, íˆìŠ¤í† ë¦¬ì˜ ë§ˆì§€ë§‰(len-1)ì€ ìƒëŒ€ë°©, ê·¸ ì „(len-2)ì€ ë‚˜, ê·¸ ì „ì „(len-3)ì€ ìƒëŒ€ë°©...
let aggroCount = 0;
let hLen = game.hist.length;
// ìƒëŒ€ë°©ì˜ ìµœê·¼ 2ë²ˆ í–‰ë™(ì§ì „, 3í„´ì „)ë§Œ ì²´í¬
[1, 3].forEach(offset => {
    let idx = hLen - offset;
    // [2:Half, 3:Pot, 4:Over, 5:Allin] ê³µê²©ì  ì•¡ì…˜ì¸ì§€ í™•ì¸
    if (idx >= 0 && [2, 3, 4, 5].includes(game.hist[idx])) {
        aggroCount++;
    }
});

// 4. EV+ Hero Call (ë™ì  ë¸”ëŸ¬í”„ ê°ì§€)
let effectiveBluffRate = userStats.getBluffRate();

// ìƒëŒ€ê°€ ìµœê·¼ 2ë²ˆì˜ ê¸°íšŒ ì¤‘ 1ë²ˆ ì´ìƒ ê³µê²©ì ì´ì—ˆë‹¤ë©´? -> ë¶„ìœ„ê¸° íƒì§€
if (aggroCount >= 1) { 
    effectiveBluffRate += 0.15; // "ì–´? ì–˜ ì§€ê¸ˆ ë‹¬ë¦¬ëŠ” ì¤‘ì´ë„¤?" (ê°ì§€ìœ¨ 15% ë¶€ìŠ¤íŠ¸)
    // 2ë²ˆ ì—°ì† ê³µê²©ì´ë©´ ë” ì˜ì‹¬ (ì„ íƒì‚¬í•­)
    if (aggroCount >= 2) effectiveBluffRate += 0.10; 
}

// ì¡°ê±´: ìƒëŒ€ê°€ ë¯¸ì¹œë“¯ì´ ê³µê²© ì¤‘(BluffRate ë†’ìŒ) + ë‚´ íŒ¨ëŠ” ì• ë§¤(30~65%) + íŒŸ ì˜¤ì¦ˆëŠ” ë‚˜ì¨(ë¹„ìŒˆ)
if (effectiveBluffRate > 0.3 && equity > 0.3 && equity < 0.65 && requiredEquity > 0.3) {
    
    // Pot Oddsê°€ ì•ˆ ë‚˜ì™€ë„(ë¹„ì‹¸ë„), ìƒëŒ€ê°€ ë»¥ì¹´ì¼ í™•ë¥ ì´ ë†’ìœ¼ë‹ˆ ì½œì„ ë•€ (EV+)
    // 45% ì´ìƒì˜ 'ìƒìŠµë²”'ì´ë©´ 70% í™•ë¥ ë¡œ ì½œ ì „í™˜, ì•„ë‹ˆë©´ 50%
    let heroFactor = effectiveBluffRate > 0.45 ? 0.7 : 0.5;
    
    let shift = strat[ACT.FOLD] * heroFactor;
    strat[ACT.FOLD] -= shift;
    
    // Check(Call)ì— ë¹„ì¤‘ì„ ì‹£ë˜, ìƒí™©ì— ë”°ë¼ Half ë² íŒ…ìœ¼ë¡œ ì—­ê³µ(Re-raise)ë„ ì‚´ì§ ê³ ë ¤ ê°€ëŠ¥
    // ì—¬ê¸°ì„  ì•ˆì „í•˜ê²Œ Check(Call)ë¡œ ëª°ì•„ì¤Œ
    if (valid.includes(ACT.CHECK)) strat[ACT.CHECK] += shift;

    // UI ì•Œë¦¼
    let heroEl = document.getElementById('ai-hero');
    heroEl.style.display = 'block';
    heroEl.innerText = `ğŸ‘ï¸ Hero Call! (Bluff ${(effectiveBluffRate*100).toFixed(0)}% / Aggro detected)`;
}

    // 1. ê¸°ë³¸ Bias (ìŠ¹ë¥  ê¸°ë°˜)
    let bias = (equity - 0.5) * 2.35;
    if(bias > 0) {
        [ACT.BET_H, ACT.BET_P, ACT.ALLIN].forEach(a => { if(valid.includes(a)) strat[a]*=(1+bias*1.5); });
        if(valid.includes(ACT.FOLD)) strat[ACT.FOLD]*=(1-bias*0.8);
    } else {
        let def = Math.abs(bias);
        if(valid.includes(ACT.FOLD)) strat[ACT.FOLD]*=(1+def*2.0);
        [ACT.BET_H, ACT.BET_P, ACT.ALLIN].forEach(a => { if(valid.includes(a)) strat[a]*=(1-def*0.8); });
    }

    // 2. [UPDATE] ë³´ìˆ˜ì ì¸ 10 íŒ¨ë„í‹° íšŒí”¼ ë¡œì§
    // 10ì¼ í™•ë¥  10% ë¯¸ë§Œì´ë©´ ë¬´ì‹œ. ê·¸ ì´ìƒì¼ ë•Œë§Œ ì„ í˜•ì ìœ¼ë¡œ í´ë“œ í™•ë¥  ê°ì†Œ.
    // ìµœëŒ€ ê°ì†Œí­ 80% (ì´ì „ì—ëŠ” 100%ì—¬ì„œ ì ˆëŒ€ ì•ˆ ì£½ìŒ)
    if (probTen > 0.1 && valid.includes(ACT.FOLD)) {
        let penaltyFactor = Math.min(Math.max(probTen - 0.1, 0) * 2.5, 0.8);
        
        let foldProb = strat[ACT.FOLD];
        let reduceAmount = foldProb * penaltyFactor; 
        
        strat[ACT.FOLD] -= reduceAmount;
        let safeOption = valid.includes(ACT.CHECK) ? ACT.CHECK : 
                         (valid.includes(ACT.BET_H) ? ACT.BET_H : -1);
        if(safeOption !== -1) strat[safeOption] += reduceAmount;
        strat[ACT.FOLD] = Math.max(strat[ACT.FOLD], 0.05); // ìµœì†Œ 5%ëŠ” ë‚¨ê¹€
    }


    // 4. ì‚¬ìš©ì í´ë“œ ì„±í–¥ ëŒ€ì‘ (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
    if (userStats.totalHands >= 5) {
        let diff = userStats.getFoldRate() - 0.4;
        let mult = Math.min(Math.max(1.0 + (diff*0.5), 0.6), 1.5);
        [ACT.BET_H, ACT.BET_P, ACT.ALLIN].forEach(a => { if(valid.includes(a)) strat[a] *= mult; });
    }

    let vSum=0; valid.forEach(a=>vSum+=strat[a]);
    let action = valid.includes(ACT.CHECK)?ACT.CHECK:ACT.FOLD;
    if(vSum>0) {
        let r=Math.random(), cum=0;
        for(let a of valid) { cum+=strat[a]/vSum; if(r<=cum){action=a; break;} }
    }

    log(`ğŸ¤– AI: ${ACT_TXT[action]}`, 'l-ai');
    game.apply(action);
    if(game.done) endRound(); else updateUI();
}

function act(a) {
    if(game.turn!==1) return;
    if(a===ACT.FOLD) userStats.foldCount++;
    log(`ğŸ‘¤ You: ${ACT_TXT[a]}`, 'l-user');
    game.apply(a);
    if(game.done) endRound(); else runAI();
}

function actCustom() {
    if(game.turn!==1) return;
    let val = parseInt(document.getElementById('bet-slider').value);
    let diff = game.bets[0] - game.bets[1];
    
    let pot = game.pot + diff;
    let ratio = val / pot;
    let aiAct = ACT.BET_P; 
    if (val === game.stacks[1]) aiAct = ACT.ALLIN;
    else if (val <= diff) aiAct = ACT.CHECK;
    else if (ratio < 0.4) aiAct = ACT.BET_H;
    else if (ratio < 1.2) aiAct = ACT.BET_P; 
    else aiAct = ACT.BET_O;

    let txt = (val === diff && diff > 0) ? "Call" : "Bet";
    log(`ğŸ‘¤ You: ${txt} ${val} (Custom)`, 'l-user');
    
    game.apply(aiAct, val);
    if(game.done) endRound(); else runAI();
}

function endRound() {
    updateUI(true); // ì¹´ë“œ ê³µê°œ

    // 1. ìŠ¹íŒ¨ íŒì •
    let r0 = game.hands[0].r, r1 = game.hands[1].r;
    let winner = -1; // -1: ë¬´ìŠ¹ë¶€, 0: AI ìŠ¹, 1: í”Œë ˆì´ì–´ ìŠ¹
    let last = game.hist[game.hist.length-1];

    if(last === ACT.FOLD) {
        winner = 1 - game.turn; // í´ë“œí•œ ì‚¬ëŒì˜ ë°˜ëŒ€í¸ì´ ìŠ¹ë¦¬
    } else {
        // ì‡¼ë‹¤ìš´ íŒì • (í˜ëª… í¬í•¨)
        if((r0===1 && r1===10)) winner = 0;       // AI í˜ëª… ìŠ¹
        else if((r0===10 && r1===1)) winner = 1; // í”Œë ˆì´ì–´ í˜ëª… ìŠ¹
        else if(r0 > r1) winner = 0;
        else if(r1 > r0) winner = 1;
    }

    // 2. ì¹© ì •ì‚° ì¤€ë¹„
    // ì¼ë‹¨ íŒëˆì„ ë‹¤ ê±·ì–´ê°”ë‹¤ê³  ê°€ì • (ë‚´ ìŠ¤íƒì—ì„œ ì°¨ê°)
    chips[0] -= game.contrib[0];
    chips[1] -= game.contrib[1];

    if(last === ACT.FOLD) {
        let folder = game.turn; // ì£½ì€ ì‚¬ëŒ
        // ì£½ì€ ì‚¬ëŒ íŒ¨ê°€ 10ì´ë©´ íŒ¨ë„í‹° ë¶€ê³¼ (ìƒëŒ€ì—ê²Œ 10ì¹© ì „ë‹¬)
        if(game.hands[folder].r === 10) {
            if(folder === 0) { chips[0] -= 10; chips[1] += 10; }
            else { chips[1] -= 10; chips[0] += 10; }
        }
    }

    // [ì¤‘ìš”] ì´ˆê³¼ ë² íŒ…ê¸ˆ(Excess) ê³„ì‚°: ì½œ ë°›ì§€ ì•Šì€ ê¸ˆì•¡ì€ ì¦‰ì‹œ í™˜ë¶ˆ (Uncalled Bet)
    // ì˜ˆ: ë‚˜ 5 ë² íŒ…, AI í´ë“œ -> ì°¨ì•¡ 5ëŠ” ë‚´ê°€ ë‹¤ì‹œ ê°€ì ¸ê° (ìŠ¹ë¦¬ ê¸ˆì•¡ ì•„ë‹˜)
    let excess = Math.abs(game.contrib[0] - game.contrib[1]);
    let refund0 = 0, refund1 = 0;
    
    if(game.contrib[0] > game.contrib[1]) {
        chips[0] += excess;
        refund0 = excess; // AIê°€ ëŒë ¤ë°›ì€ ê¸ˆì•¡
    } else {
        chips[1] += excess;
        refund1 = excess; // ë‚´ê°€ ëŒë ¤ë°›ì€ ê¸ˆì•¡
    }

    // ì‹¤ì œ ìŠ¹ë¶€ íŒŸ (ì´ˆê³¼ê¸ˆì„ ì œì™¸í•œ ë§¤ì¹­ëœ ê¸ˆì•¡)
    let mainPot = game.pot - excess;

    let aiCard = document.getElementById('c-ai');
    let myCard = document.getElementById('c-me');

    // 3. ë°°ì§€ ë° í†µê³„ ì²˜ë¦¬
    if(last === ACT.FOLD) {
        let folder = game.turn;
        if(game.hands[folder].r === 10) {
            addBadge(folder===0?aiCard:myCard, "-10 PENALTY", 'bg-pen');
            log("ğŸš¨ 10-Holding Penalty!", "l-warn");
        }
    } else {
        if( (r0===1 && r1===10) || (r0===10 && r1===1) ) {
            log("âš¡ REVOLUTION! (1 > 10)", "l-warn");
            addBadge(winner===0?aiCard:myCard, "1 > 10 WIN", 'bg-rev');
        }
        // ë¸”ëŸ¬í•‘ ê°ì§€ í†µê³„
        if(winner === 0 && r1 <= 6 && game.contrib[1] > 10) {
             userStats.bluffOpportunities++;
             userStats.bluffsDetected++;
             log(`ğŸ•µï¸ Bluff Detected! (Rank ${r1})`, 'l-sys');
        } else if (winner === 0) {
             userStats.bluffOpportunities++;
        }
    }

    // 4. íŒŸ ë¶„ë°° ë° ë¡œê·¸ ì¶œë ¥ ìˆ˜ì •
    if(winner === 0) { // AI ìŠ¹ë¦¬
        chips[0] += mainPot;
        window.carriedPot = 0;
        
        // [FIX] ë¡œê·¸ ê³„ì‚°: (ë©”ì¸íŒŸ + í™˜ë¶ˆê¸ˆ) - ë‚´ ì´ íˆ¬ìê¸ˆ
        let profit = (mainPot + refund0) - game.contrib[0]; 
        log(`ğŸ’€ LOSE (-${(game.contrib[1] - refund1).toFixed(0)})`, 'l-ai'); // ë‚´ ì†í•´ëŠ” (ë‚¸ ëˆ - ëŒë ¤ë°›ì€ ëˆ)
        
        aiCard.classList.add('winner'); myCard.classList.add('loser');
    } 
    else if(winner === 1) { // í”Œë ˆì´ì–´ ìŠ¹ë¦¬
        chips[1] += mainPot;
        window.carriedPot = 0;

        // [FIX] ë¡œê·¸ ê³„ì‚°: (ë©”ì¸íŒŸ + í™˜ë¶ˆê¸ˆ) - ë‚´ ì´ íˆ¬ìê¸ˆ
        // ì˜ˆ: íŒŸ 2, ë‚˜ 5ë² íŒ…(ì´6), AIí´ë“œ -> í™˜ë¶ˆ5. ë©”ì¸íŒŸ2.
        // ì´ìµ = (2 + 5) - 6 = +1 (ì •ìƒ)
        let profit = (mainPot + refund1) - game.contrib[1];
        log(`ğŸ‰ WIN (+${profit.toFixed(0)})`, 'l-user');

        myCard.classList.add('winner'); aiCard.classList.add('loser');
    } 
    else { // ë¬´ìŠ¹ë¶€
        if (chips[0] < 1 || chips[1] < 1) {
            log(`ğŸ¤ All-in Draw! Chips Returned.`, 'l-sys');
            chips[0] += mainPot / 2;
            chips[1] += mainPot / 2;
            window.carriedPot = 0;
        } else {
            log(`ğŸ¤ DRAW - Pot (${mainPot}) Carried Over!`, 'l-sys');
            window.carriedPot = mainPot;
        }
    }

    // 5. ê²Œì„ ì¢…ë£Œ ì—¬ë¶€ (íŒŒì‚° ì²´í¬)
    if (chips[0] < 1 || chips[1] < 1) {
        setTimeout(() => {
            let msg = chips[0] < 1 ? "ğŸ‰ YOU WIN THE GAME! ğŸ‰" : "ğŸ’€ GAME OVER ğŸ’€";
            alert(msg);
            location.reload();
        }, 1000);
    } else {
        setTimeout(startRound, 2500);
    }
}

function addBadge(el, txt, cls) {
    let b = document.createElement('div'); b.className = 'badge '+cls; b.innerText = txt; el.appendChild(b);
}
</script>
</body>
</html>

