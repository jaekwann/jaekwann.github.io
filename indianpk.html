<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Hold'em AI (Pro Version)</title>
    <style>
        /* UI Ïä§ÌÉÄÏùºÏùÄ Í∏∞Ï°¥Í≥º ÎèôÏùºÌïòÍ≤å Ïú†ÏßÄÌïòÎêò, ÏïΩÍ∞Ñ Îçî ÏßÑÏßÄÌïú ÌÜ§ÏúºÎ°ú Î≥ÄÍ≤Ω */
        :root { --bg-color: #212121; --table-color: #1b5e20; --card-bg: #e0e0e0; --text-color: #eee; --accent-color: #ffd700; --btn-color: #1976d2; }
        body { font-family: 'Roboto', 'Segoe UI', sans-serif; background-color: var(--bg-color); color: var(--text-color); margin: 0; padding: 20px; display: flex; justify-content: center; align-items: flex-start; min-height: 100vh; }
        .container { width: 100%; max-width: 500px; background-color: #333; border-radius: 12px; overflow: hidden; box-shadow: 0 12px 24px rgba(0,0,0,0.6); position: relative; }
        
        #loading-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(33, 33, 33, 0.95); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; }
        #progress-container { width: 80%; height: 16px; background: #555; border-radius: 8px; margin-top: 15px; overflow: hidden; }
        #progress-bar { width: 0%; height: 100%; background: linear-gradient(90deg, #ffd700, #ff8c00); transition: width 0.1s; }
        #loading-text { font-weight: bold; margin-top: 10px; color: var(--accent-color); font-size: 1.1em; text-align: center;}

        .header { background: #263238; padding: 15px; text-align: center; border-bottom: 2px solid #4caf50; }
        .stats-row { display: flex; justify-content: space-around; font-weight: bold; font-size: 1.1em; }
        
        .table { background: radial-gradient(circle, #2e7d32 0%, #1b5e20 100%); padding: 20px; min-height: 380px; text-align: center; position: relative; }
        .card-area { display: flex; justify-content: space-between; margin: 20px 0; }
        .player-box { background: rgba(0,0,0,0.4); border-radius: 10px; padding: 10px; width: 45%; border: 1px solid rgba(255,255,255,0.1); }
        
        .card { background: var(--card-bg); color: #333; width: 60px; height: 90px; border-radius: 6px; display: inline-flex; justify-content: center; align-items: center; font-size: 1.8em; font-weight: bold; margin-top: 5px; box-shadow: 2px 2px 8px rgba(0,0,0,0.4); }
        .card.red { color: #d32f2f; } .card.black { color: #212121; } .card.hidden { background: #607d8b; color: #cfd8dc; }
        .pot-display { background: rgba(0,0,0,0.6); padding: 5px 20px; border-radius: 20px; display: inline-block; font-weight: bold; color: var(--accent-color); border: 1px solid var(--accent-color); margin-bottom: 10px;}

        /* AI Thought */
        .ai-thought { background: rgba(255,255,255,0.95); color: #222; border-radius: 8px; padding: 10px; width: 90%; margin: 0 auto 10px auto; font-size: 0.85em; display: none; box-shadow: 0 4px 8px rgba(0,0,0,0.3); text-align: left; }
        .bar-container { display: flex; height: 12px; margin-top: 6px; border-radius: 6px; overflow: hidden; background: #ddd; }
        .bg-red { background: #f44336; } .bg-yellow { background: #ffeb3b; } .bg-green { background: #4caf50; }
        .typing span { display: inline-block; width: 4px; height: 4px; background: #333; border-radius: 50%; animation: type 1s infinite; margin: 0 2px; }
        .typing span:nth-child(2) { animation-delay: 0.2s; } .typing span:nth-child(3) { animation-delay: 0.4s; }
        @keyframes type { 0%,100%{transform:translateY(0);} 50%{transform:translateY(-4px);} }

        .controls { padding: 15px; background: #263238; display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        button { padding: 12px; border: none; border-radius: 6px; color: white; cursor: pointer; font-weight: bold; font-size: 1em; transition: 0.2s; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        button:active { transform: scale(0.96); } button:disabled { opacity: 0.4; cursor: not-allowed; filter: grayscale(100%); }
        .btn-fold { background: #c62828; grid-column: span 2; } .btn-check { background: #2e7d32; grid-column: span 2; }
        .btn-bet { background: #1565c0; } .btn-allin { background: #6a1b9a; }

        .logs { height: 130px; overflow-y: auto; background: #111; color: #bbb; font-size: 0.85em; padding: 10px; border-top: 1px solid #444; text-align: left; scrollbar-width: thin; }
        .log-entry { border-bottom: 1px solid #333; padding-bottom: 3px; margin-bottom: 3px; }
        .log-ai { color: #ffb74d; } .log-user { color: #64b5f6; } .log-sys { color: #90a4ae; font-style: italic; }
    </style>
</head>
<body>

<div class="container">
    <div id="loading-overlay">
        <div class="spinner"></div>
        <div id="loading-text">Applying Linear CFR...<br><span style="font-size:0.8em; color:#bbb;">Optimizing Strategy</span></div>
        <div id="progress-container"><div id="progress-bar"></div></div>
    </div>

    <div class="header">
        <div class="stats-row">
            <span>ü§ñ AI: <span id="ai-stack">100.0</span></span>
            <span>R<span id="round-num">1</span></span>
            <span>üë§ You: <span id="my-stack">100.0</span></span>
        </div>
    </div>

    <div class="table">
        <div class="ai-thought" id="ai-thought-box">
            <div id="ai-msg">Analyzing...</div>
            <div style="margin-top:8px; font-weight:bold; font-size:0.9em; color:#444;">AI's Estimation of its OWN Hand:</div>
            <div class="bar-container" id="belief-bar">
                <div class="bg-red" style="width:33%"></div>
                <div class="bg-yellow" style="width:33%"></div>
                <div class="bg-green" style="width:33%"></div>
            </div>
            <div style="display:flex; justify-content:space-between; font-size:0.75em; color:#666; margin-top:2px;">
                <span>Weak (1-5)</span><span>Mid (6-8)</span><span>Strong (9-10)</span>
            </div>
        </div>

        <div class="card-area">
            <div class="player-box">
                <div>AI (Bet: <span id="ai-bet">0</span>)</div>
                <div class="card" id="ai-card">?</div>
            </div>
            <div class="player-box">
                <div>You (Bet: <span id="my-bet">0</span>)</div>
                <div class="card hidden" id="my-card">?</div>
            </div>
        </div>

        <div class="pot-display">Pot: <span id="pot-size">2.0</span></div>
        <div id="game-status" style="color:#cfd8dc; font-size:0.9em; margin-top:10px; font-style:italic;">Ready</div>
    </div>

    <div class="controls">
        <button class="btn-fold" onclick="humanAction(0)">Fold</button>
        <button class="btn-check" id="btn-check" onclick="humanAction(1)">Check</button>
        <button class="btn-bet" id="btn-bet1" onclick="humanAction(2)">Bet Small (33%)</button>
        <button class="btn-bet" id="btn-bet2" onclick="humanAction(3)">Bet Large (75%)</button>
        <button class="btn-bet" id="btn-bet3" onclick="humanAction(4)">Overbet (150%)</button>
        <button class="btn-allin" onclick="humanAction(5)">All-In</button>
    </div>
    <div class="logs" id="log-box"></div>
</div>

<script>
// --- CONFIG ---
const RANKS = [1,2,3,4,5,6,7,8,9,10];
const SUITS = ['s','h','d','c'];
const SYMBOLS = {'s':'‚ô†','h':'‚ô•','d':'‚ô¶','c':'‚ô£'};
const ACT = { FOLD:0, CHECK:1, BET_S:2, BET_L:3, BET_O:4, ALLIN:5 };
const ACT_NAMES = ["Fold", "Check/Call", "Bet Small", "Bet Large", "Overbet", "All-In"];
const BET_MULTS = { 2:0.33, 3:0.75, 4:1.5, 5:999.0 };

// --- HELPERS ---
function delay(ms) { return new Promise(r => setTimeout(r, ms)); }
function nextFrame() { return new Promise(r => setTimeout(r, 0)); }
function weightedChoice(probs) {
    let r = Math.random(), sum = 0;
    for(let i=0; i<probs.length; i++) {
        sum += probs[i];
        if(r <= sum) return i;
    }
    return probs.length-1;
}

// --- MCCFR ENGINE (Linear CFR) ---
class Node {
    constructor(n) { 
        this.regret = new Float32Array(n); 
        this.strategy = new Float32Array(n); 
    }
    getStrategy() {
        let r = this.regret.map(v => Math.max(v, 0));
        let sum = r.reduce((a,b)=>a+b, 0);
        return sum > 0 ? r.map(v => v/sum) : r.map(()=>1/this.regret.length);
    }
    getAvgStrategy() {
        let sum = this.strategy.reduce((a,b)=>a+b, 0);
        return sum > 0 ? this.strategy.map(v => v/sum) : this.strategy.map(()=>1/this.strategy.length);
    }
}

class Solver {
    constructor() { this.nodes = {}; }
    getNode(key) { if(!this.nodes[key]) this.nodes[key] = new Node(6); return this.nodes[key]; }
    
    // [Upgrade] Linear CFR: Discounting applied via 'weight' (iteration number)
    async train(iters, onProgress) {
        const BATCH_SIZE = 50; 
        
        for(let i=0; i<iters; i+=BATCH_SIZE) {
            for(let j=0; j<BATCH_SIZE && (i+j)<iters; j++) {
                let currentIter = i + j + 1;
                // [Upgrade] Discounting Weight: t (Linear) or t^2. Using Linear 't' here.
                // Recent iterations matter more.
                let weight = currentIter; 

                // [Upgrade] Targeted Stack Training
                // 50% chance: Train near 100bb (Starting stack)
                // 50% chance: Train random 20-200bb (Deep/Short stack robustness)
                let s0, s1;
                if (Math.random() < 0.5) {
                    s0 = Math.floor(Math.random() * 40) + 80; // 80~120
                    s1 = Math.floor(Math.random() * 40) + 80;
                } else {
                    s0 = Math.floor(Math.random() * 180) + 20; // 20~200
                    s1 = Math.floor(Math.random() * 180) + 20;
                }

                let state = new State(s0, s1);
                state.turn = Math.random()<0.5 ? 0 : 1;
                this.cfr(state, (i+j)%2, 1.0, weight);
            }
            if(onProgress) onProgress((i+BATCH_SIZE)/iters);
            await nextFrame(); 
        }
    }

    cfr(state, p, pr, weight) {
        if(state.done) return state.getPayoff(p);
        let valid = state.validActions();
        if(valid.length===0) return 0;

        let key = `Opp:${state.hands[1-state.turn].r}|Seq:${state.hist.join('')}`;
        let node = this.getNode(key);
        let strat = node.getStrategy();
        
        let probs = new Float32Array(6);
        let sum = 0;
        valid.forEach(a => { probs[a] = strat[a]; sum += strat[a]; });
        if(sum > 0) probs = probs.map(v => v/sum);
        else valid.forEach(a => probs[a] = 1.0/valid.length);

        if(state.turn !== p) {
            let a = weightedChoice(probs);
            if(!valid.includes(a)) a = valid[Math.floor(Math.random()*valid.length)];
            let next = state.clone(); next.apply(a);
            return this.cfr(next, p, pr, weight);
        } else {
            let util = new Float32Array(6);
            let nodeUtil = 0;
            valid.forEach(a => {
                let next = state.clone(); next.apply(a);
                util[a] = this.cfr(next, p, pr * probs[a], weight);
                nodeUtil += probs[a] * util[a];
            });
            
            // [Upgrade] Apply Linear Weighting to Regret and Strategy
            valid.forEach(a => {
                let regret = util[a] - nodeUtil;
                node.regret[a] += regret * weight; // Weighted Regret
                node.strategy[a] += (pr * probs[a]) * weight; // Weighted Strategy
            });
            return nodeUtil;
        }
    }
}

class State {
    constructor(s0, s1) {
        this.deck = [];
        for(let r of RANKS) for(let s of SUITS) this.deck.push({r,s});
        for(let i=39; i>0; i--) { let j=Math.floor(Math.random()*(i+1)); [this.deck[i],this.deck[j]]=[this.deck[j],this.deck[i]]; }
        this.stacks = [s0-1, s1-1];
        this.bets = [1, 1];
        this.pot = 2;
        this.contrib = [1, 1];
        this.hands = [this.deck.pop(), this.deck.pop()];
        this.hist = [];
        this.turn = 1; 
        this.done = false;
    }
    
    validActions() {
        let me = this.turn, opp = 1-me;
        if(this.stacks[me]<=0) return [ACT.FOLD, ACT.CHECK];
        if(this.stacks[opp]<=0 && this.bets[opp]>this.bets[me]) return [ACT.FOLD, ACT.CHECK];
        
        let aggressiveActs = this.hist.filter(a => a >= ACT.BET_S).length;
        if(aggressiveActs >= 3) return [ACT.FOLD, ACT.CHECK]; 

        let acts = [ACT.FOLD, ACT.CHECK];
        let diff = this.bets[opp] - this.bets[me];
        let target = this.pot + diff;
        
        if(!this.done) {
            for(let a of [2,3,4,5]) {
                if(a===ACT.ALLIN) { acts.push(a); continue; }
                let raise = target * BET_MULTS[a];
                if((diff + raise) < this.stacks[me] && raise >= 1) acts.push(a);
            }
        }
        return acts;
    }

    apply(a) {
        this.hist.push(a);
        let me = this.turn, opp = 1-me;
        if(a===ACT.FOLD) { this.done = true; return; }
        
        let diff = this.bets[opp] - this.bets[me];
        let amt = 0;
        if(a===ACT.CHECK) amt = Math.min(diff, this.stacks[me]);
        else if(a===ACT.ALLIN) amt = this.stacks[me];
        else {
            let raise = (this.pot + diff) * BET_MULTS[a];
            amt = diff + raise;
            if(amt > this.stacks[me]) amt = this.stacks[me];
        }
        
        this.stacks[me] -= amt;
        this.bets[me] += amt;
        this.contrib[me] += amt;
        this.pot += amt;
        
        if(a===ACT.CHECK && this.bets[0]===this.bets[1] && this.hist.length>=1) {
             if(this.hist.length>=2 || diff>0) this.done = true;
        }
        if(!this.done) this.turn = opp;
    }
    
    getPayoff(p) {
        let opp = 1-p;
        if(this.hist[this.hist.length-1] === ACT.FOLD) {
            if(this.turn === p) return -this.contrib[p];
            else return this.pot - this.contrib[p];
        }
        let r1 = this.hands[p].r, r2 = this.hands[opp].r;
        if(r1 > r2) return this.pot - this.contrib[p];
        if(r1 < r2) return -this.contrib[p];
        return this.pot/2 - this.contrib[p];
    }
    
    clone() {
        let s = new State(0,0);
        s.deck = [...this.deck]; s.stacks=[...this.stacks]; s.bets=[...this.bets];
        s.pot=this.pot; s.contrib=[...this.contrib]; s.hands=[...this.hands];
        s.hist=[...this.hist]; s.turn=this.turn; s.done=this.done;
        return s;
    }
}

// --- UI & MAIN ---
let solver = new Solver();
let aiChips = 100, myChips = 100;
let game = null, round = 0;

window.onload = function() {
    let bar = document.getElementById('progress-bar');
    let txt = document.getElementById('loading-text');
    
    // 5000 Iterations with Linear Weighting
    solver.train(20000, (pct) => {
        let p = Math.min(100, Math.floor(pct*100));
        bar.style.width = p + '%';
        txt.innerHTML = `Applying Linear CFR... ${p}%`;
    }).then(() => {
        document.getElementById('loading-overlay').style.display = 'none';
        startRound();
    });
};

function log(msg, cls) {
    let div = document.createElement('div');
    div.innerText = msg; div.className = 'log-entry '+cls;
    let box = document.getElementById('log-box');
    box.appendChild(div); box.scrollTop = box.scrollHeight;
}

function updateUI() {
    document.getElementById('ai-stack').innerText = game.stacks[0].toFixed(1);
    document.getElementById('my-stack').innerText = game.stacks[1].toFixed(1);
    document.getElementById('pot-size').innerText = game.pot.toFixed(1);
    document.getElementById('ai-bet').innerText = game.bets[0].toFixed(1);
    document.getElementById('my-bet').innerText = game.bets[1].toFixed(1);
    document.getElementById('round-num').innerText = round;

    let aiC = game.hands[0];
    let el0 = document.getElementById('ai-card');
    el0.innerText = aiC.r + SYMBOLS[aiC.s];
    el0.className = `card ${['h','d'].includes(aiC.s)?'red':'black'}`;
    
    let el1 = document.getElementById('my-card');
    if(game.done) {
        let myC = game.hands[1];
        el1.innerText = myC.r + SYMBOLS[myC.s];
        el1.className = `card ${['h','d'].includes(myC.s)?'red':'black'}`;
    } else {
        el1.innerText = "?"; el1.className = "card hidden";
    }

    let btns = document.querySelectorAll('.controls button');
    let valid = game.validActions();
    btns.forEach(b => b.disabled = true);
    
    if(!game.done && game.turn === 1) {
        let diff = Math.max(0, game.bets[0] - game.bets[1]);
        document.getElementById('btn-check').innerText = diff===0 ? "Check" : `Call (${diff.toFixed(1)})`;
        if(valid.includes(ACT.FOLD)) btns[0].disabled = false;
        if(valid.includes(ACT.CHECK)) btns[1].disabled = false;
        if(valid.includes(ACT.BET_S)) btns[2].disabled = false;
        if(valid.includes(ACT.BET_L)) btns[3].disabled = false;
        if(valid.includes(ACT.BET_O)) btns[4].disabled = false;
        if(valid.includes(ACT.ALLIN)) btns[5].disabled = false;
    }
}

function startRound() {
    if(aiChips<=0 || myChips<=0) { alert(aiChips<=0 ? "You Win!" : "You Lose!"); return; }
    round++;
    game = new State(aiChips, myChips);
    log(`--- Round ${round} ---`, 'log-sys');
    document.getElementById('ai-thought-box').style.display = 'none';
    updateUI();
    if(game.turn === 0) runAI();
}

async function runAI() {
    updateUI();
    document.getElementById('ai-thought-box').style.display = 'block';
    
    // [Upgrade] Dynamic Belief Visualization based on Bet Size
    let belief = new Float32Array(11).fill(1);
    game.hist.forEach(a => {
        if(a===ACT.CHECK) { 
            // Check suggests strength (trapping) or mid strength
            for(let i=1;i<=5;i++) belief[i]*=0.6; 
            for(let i=6;i<=10;i++) belief[i]*=1.4; 
        }
        else if(a===ACT.BET_S) { 
            // Small bet: Maybe value extraction or weak bluff
            for(let i=1;i<=5;i++) belief[i]*=1.2; 
            for(let i=6;i<=10;i++) belief[i]*=0.8; 
        }
        else if(a===ACT.BET_L || a===ACT.BET_O || a===ACT.ALLIN) { 
            // Big bet: Polarized (Very strong or Very weak/Bluff)
            // Human tends to bet big when they see opponent is weak (so they think they are strong?)
            // No, human bets big -> human sees LOW card on AI.
            // So AI thinks it has LOW card.
            for(let i=1;i<=5;i++) belief[i]*=2.0; 
            for(let i=6;i<=10;i++) belief[i]*=0.4; 
        }
    });
    let sum=0; for(let i=1;i<=10;i++) sum+=belief[i];
    let low=0, mid=0, high=0;
    for(let i=1;i<=5;i++) low+=belief[i];
    for(let i=6;i<=8;i++) mid+=belief[i];
    for(let i=9;i<=10;i++) high+=belief[i];
    
    let bars = document.getElementById('belief-bar').children;
    bars[0].style.width = (low/sum*100)+'%';
    bars[1].style.width = (mid/sum*100)+'%';
    bars[2].style.width = (high/sum*100)+'%';
    
    let msg = document.getElementById('ai-msg');
    msg.innerHTML = 'Thinking<span class="typing"><span></span><span></span><span></span></span>';
    
    await delay(1500);
    
    let key = `Opp:${game.hands[1].r}|Seq:${game.hist.join('')}`;
    let node = solver.getNode(key);
    let strat = node.getAvgStrategy();
    let valid = game.validActions();
    
    let probs = [], pSum = 0;
    valid.forEach(a => { probs.push(strat[a]); pSum+=strat[a]; });
    if(pSum>0) probs = probs.map(p=>p/pSum);
    else probs = probs.map(()=>1/valid.length);
    
    let choiceIdx = weightedChoice(probs);
    let action = valid[choiceIdx];
    
    log("ü§ñ AI: " + ACT_NAMES[action], 'log-ai');
    msg.innerText = "I choose: " + ACT_NAMES[action];
    game.apply(action);
    
    if(game.done) endRound();
    else updateUI();
}

function humanAction(a) {
    if(game.turn !== 1) return;
    log("üë§ You: " + ACT_NAMES[a], 'log-user');
    game.apply(a);
    if(game.done) endRound();
    else runAI();
}

function endRound() {
    updateUI();
    let p = game.getPayoff(1);
    myChips += p; aiChips -= p;
    setTimeout(() => {
        if(p>0) log(`üéâ You Won ${p.toFixed(1)}`, 'log-sys');
        else if(p<0) log(`üíÄ You Lost ${Math.abs(p).toFixed(1)}`, 'log-sys');
        else log(`ü§ù Tie`, 'log-sys');
        setTimeout(startRound, 2000);
    }, 500);
}
</script>
</body>
</html>
