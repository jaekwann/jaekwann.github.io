<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Hold'em : Advanced AI</title>
    <style>
        :root { --bg-color: #121212; --table-bg: #1b5e20; --card-bg: #eee; --accent: #ffd700; --danger: #ef5350; --btn-primary: #1565c0; }
        body { font-family: 'Segoe UI', Roboto, sans-serif; background: var(--bg-color); color: #e0e0e0; margin: 0; display: flex; justify-content: center; min-height: 100vh; overflow: hidden; }
        
        .container { width: 100%; max-width: 480px; background: #1e1e1e; display: flex; flex-direction: column; height: 100vh; position: relative; box-shadow: 0 0 30px rgba(0,0,0,0.8); }

        /* Loading */
        #loading-screen { position: absolute; inset: 0; background: rgba(18,18,18,0.98); z-index: 100; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        .loader-bar-box { width: 70%; height: 6px; background: #333; border-radius: 3px; margin-top: 15px; overflow: hidden; }
        .loader-bar { height: 100%; width: 0%; background: linear-gradient(90deg, #ffd700, #ff8f00); transition: width 0.2s; }
        
        /* Header */
        .header { padding: 15px; background: #263238; border-bottom: 2px solid #43a047; display: flex; justify-content: space-between; align-items: center; font-weight: bold; font-size: 1.1em; }
        .deck-info { background: #000; padding: 5px 12px; border-radius: 15px; font-size: 0.85em; color: var(--accent); border: 1px solid #444; box-shadow: inset 0 0 5px rgba(0,0,0,0.5); }

        /* Table */
        .table { flex: 1; background: radial-gradient(circle at center, #2e7d32 0%, #1b5e20 80%); position: relative; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 20px; }
        
        /* Pot & Status */
        .pot-box { background: rgba(0,0,0,0.6); padding: 8px 25px; border-radius: 30px; border: 1px solid var(--accent); color: var(--accent); font-weight: bold; font-size: 1.4em; margin-bottom: 20px; box-shadow: 0 4px 10px rgba(0,0,0,0.3); transition: all 0.3s; }
        .pot-box.carried { box-shadow: 0 0 20px #ffd700; border: 2px solid #fff; background: rgba(255, 215, 0, 0.2); }
        .status-msg { color: #bdbdbd; font-style: italic; font-size: 0.9em; min-height: 1.2em; margin-bottom: 10px; text-align: center; }

        /* Players & Cards */
        .play-area { display: flex; width: 100%; justify-content: space-around; align-items: center; margin: 10px 0; }
        .player { text-align: center; position: relative; width: 40%; }
        .p-info { background: rgba(0,0,0,0.5); padding: 4px 10px; border-radius: 4px; font-size: 0.85em; margin-bottom: 8px; display: inline-block; }
        
        .card { 
            width: 75px; height: 110px; background: var(--card-bg); border-radius: 8px; margin: 0 auto;
            display: flex; justify-content: center; align-items: center; font-size: 2.2em; font-weight: bold;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5); position: relative; transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .card.red { color: #c62828; } .card.black { color: #212121; }
        .card.hidden { background: repeating-linear-gradient(45deg, #455a64, #455a64 10px, #37474f 10px, #37474f 20px); color: transparent; border: 2px solid #546e7a; }
        
        .badge { position: absolute; top: -12px; right: -12px; color: white; font-size: 0.6em; padding: 4px 6px; border-radius: 8px; font-weight: bold; border:2px solid white; animation: popIn 0.3s; z-index: 20; white-space: nowrap; box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
        .bg-pen { background: var(--danger); }
        .bg-rev { background: #7b1fa2; }
        .card.winner { transform: scale(1.15); box-shadow: 0 0 25px var(--accent); border: 3px solid var(--accent); z-index: 10; }
        .card.loser { opacity: 0.5; filter: grayscale(100%); transform: scale(0.9); }

        /* AI Thought */
        .ai-brain { 
            width: 90%; background: rgba(255,255,255,0.92); color: #222; padding: 12px; 
            border-radius: 12px; margin-bottom: 20px; font-size: 0.85em; box-shadow: 0 10px 25px rgba(0,0,0,0.4);
            display: none; transform-origin: bottom; animation: floatUp 0.4s;
        }

        /* Controls */
        .controls { padding: 15px; background: #1e1e1e; display: flex; flex-direction: column; gap: 10px; border-top: 1px solid #333; }
        
        .btn-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; }
        
        .slider-box { display: flex; align-items: center; gap: 10px; background: #111; padding: 8px; border-radius: 8px; border: 1px solid #333; }
        input[type=range] { flex: 1; accent-color: var(--accent); cursor: pointer; }
        
        button { padding: 12px 2px; border: none; border-radius: 6px; color: white; font-weight: bold; font-size: 0.9em; cursor: pointer; transition: transform 0.1s; box-shadow: 0 3px 0 rgba(0,0,0,0.3); }
        button:active { transform: scale(0.96) translateY(2px); box-shadow: 0 0 0; }
        button:disabled { opacity: 0.3; cursor: not-allowed; transform: none; box-shadow: none; filter: grayscale(100%); }
        
        .btn-fold { background: #c62828; }
        .btn-check { background: #2e7d32; }
        .btn-half { background: #1565c0; }
        .btn-pot { background: #0277bd; }
        .btn-allin { background: #6a1b9a; grid-column: span 1; }
        
        .btn-custom { width: 90px; background: var(--accent); color: #000; font-size: 0.85em; padding: 8px; }

        /* Logs */
        .logs { height: 100px; overflow-y: auto; background: #000; padding: 10px; font-size: 0.8em; color: #bbb; border-top: 1px solid #333; scrollbar-width: thin; }
        .log-row { margin-bottom: 4px; border-bottom: 1px solid #222; padding-bottom: 2px; }
        .l-ai { color: #ffca28; } .l-user { color: #42a5f5; } .l-sys { color: #90a4ae; font-style: italic; } .l-warn { color: #ef5350; font-weight: bold; } .l-deck { color: #00e676; }

        @keyframes popIn { 0% {transform: scale(0);} 80% {transform: scale(1.2);} 100% {transform: scale(1);} }
        @keyframes floatUp { from {opacity:0; transform:translateY(15px);} to {opacity:1; transform:translateY(0);} }
    </style>
</head>
<body>

<div class="container">
    <div id="loading-screen">
        <div style="color:var(--accent); font-weight:bold; font-size:1.4em; text-shadow: 0 0 10px rgba(255,215,0,0.5);">Indian Hold'em</div>
        <div style="color:#aaa; font-size:0.9em; margin-bottom:20px;">Perfect AI + Hero Call</div>
        <div class="loader-bar-box"><div class="loader-bar" id="load-bar"></div></div>
        <div style="color:#777; font-size:0.8em; margin-top:10px;">Neural Training...</div>
    </div>

    <div class="header">
        <div>ü§ñ <span id="s-ai">100</span></div>
        <div class="deck-info" id="deck-ui">Deck: 20</div>
        <div>üë§ <span id="s-me">100</span></div>
    </div>

    <div class="table">
        <div class="ai-brain" id="ai-thought">
            <div id="ai-text">Thinking...</div>
            <div style="height:4px; background:#ddd; margin-top:4px; border-radius:2px; overflow:hidden;">
                <div id="win-rate-bar" style="width:50%; height:100%; background:#43a047;"></div>
            </div>
            <div id="ai-risk" style="font-size:0.75em; color:#ef5350; margin-top:2px; display:none;"></div>
            <div id="ai-hero" style="font-size:0.75em; color:#29b6f6; margin-top:2px; display:none;"></div>
        </div>

        <div class="pot-box" id="pot-box">POT: <span id="pot">2.0</span></div>

        <div class="play-area">
            <div class="player">
                <div class="p-info">AI (Bet: <span id="b-ai">1</span>)</div>
                <div class="card" id="c-ai">?</div>
            </div>
            <div class="player">
                <div class="p-info">You (Bet: <span id="b-me">1</span>)</div>
                <div class="card hidden" id="c-me">?</div>
            </div>
        </div>
        
        <div class="status-msg" id="status">Wait...</div>
    </div>

    <div class="controls">
        <div class="slider-box">
            <input type="range" id="bet-slider" min="1" max="100" value="1" oninput="updateSliderBtn()">
            <button class="btn-custom" id="btn-custom" onclick="actCustom()">Bet 1</button>
        </div>
        
        <div class="btn-grid">
            <button class="btn-fold" onclick="act(0)">Fold</button>
            <button class="btn-check" id="btn-chk" onclick="act(1)">Check</button>
            <button class="btn-half" onclick="act(2)">50%</button>
            <button class="btn-pot" onclick="act(3)">Pot</button>
        </div>
        <div class="btn-grid">
             <button class="btn-allin" onclick="act(5)" style="grid-column: span 4; background: linear-gradient(45deg, #7b1fa2, #4a148c);">ALL IN</button>
        </div>
    </div>
    
    <div class="logs" id="log-box"></div>
</div>

<script>
/* --- 1. SETTINGS --- */
const RANKS = [1,2,3,4,5,6,7,8,9,10];
const ACT = { FOLD:0, CHECK:1, BET_H:2, BET_P:3, BET_O:4, ALLIN:5 };
const ACT_TXT = ["Fold", "Check/Call", "Bet Half", "Bet Pot", "Overbet", "All-In"];
const MULTS = { 2:0.5, 3:1.0, 4:1.5, 5:999 }; 

/* --- 2. SHOE SYSTEM --- */
const shoe = {
    cards: [], max: 20,
    init: function() {
        this.cards = [];
        for(let i=0; i<2; i++) for(let r=1; r<=10; r++) this.cards.push({r, s: i===0?'s':'h'});
        for(let i=this.cards.length-1; i>0; i--) { let j=Math.floor(Math.random()*(i+1)); [this.cards[i],this.cards[j]]=[this.cards[j],this.cards[i]]; }
        log("üîÑ Deck Reshuffled", "l-deck"); updateDeckUI();
    },
    draw: function() {
        if(this.cards.length < 2) this.init();
        let c = this.cards.pop(); updateDeckUI(); return c;
    }
};

function updateDeckUI() {
    let el = document.getElementById('deck-ui');
    el.innerText = `Deck: ${shoe.cards.length}/${shoe.max}`;
    el.style.borderColor = shoe.cards.length <= 6 ? "#ef5350" : "#444";
}

/* --- 3. SOLVER (AI) --- */
class Node {
    constructor(n) { this.r = new Float32Array(n); this.s = new Float32Array(n); }
    getStrat() {
        let sum = 0, res = this.r.map(v => { let x = Math.max(v,0); sum+=x; return x; });
        return sum > 0 ? res.map(v => v/sum) : res.map(() => 1/this.r.length);
    }
    getAvgStrat() {
        let sum = this.s.reduce((a,b)=>a+b,0);
        return sum > 0 ? this.s.map(v => v/sum) : this.s.map(() => 1/this.s.length);
    }
}

class Solver {
    constructor() { this.nodes = {}; }
    getNode(key) { if(!this.nodes[key]) this.nodes[key] = new Node(6); return this.nodes[key]; }
    
    async train(iters, cb) {
        for(let i=0; i<iters; i+=100) {
            for(let j=0; j<100; j++) {
                let s0 = Math.random()<0.5 ? 100 : Math.floor(Math.random()*150)+20;
                let st = new State(s0, s0); st.turn = Math.random()<0.5?0:1;
                this.cfr(st, (i+j)%2, 1, 1);
            }
            if(cb) cb((i+100)/iters);
            await new Promise(r=>setTimeout(r,0));
        }
    }

    cfr(st, p, pr, w) {
        if(st.done) return st.payoff(p);
        let valid = st.validActs();
        if(valid.length===0) return 0;
        let key = `Opp:${st.hands[1-st.turn].r}|Seq:${st.hist.join('')}`;
        let node = this.getNode(key);
        let strat = node.getStrat();
        let probs = new Float32Array(6), sum = 0;
        valid.forEach(a => { probs[a] = strat[a]; sum += strat[a]; });
        if(sum>0) probs = probs.map(v=>v/sum); else valid.forEach(a=>probs[a]=1/valid.length);

        if(st.turn !== p) {
            let r=Math.random(), cum=0, a=valid[valid.length-1];
            for(let va of valid) { cum+=probs[va]; if(r<=cum){a=va; break;} }
            let next = st.clone(); next.apply(a);
            return this.cfr(next, p, pr, w);
        } else {
            let util = new Float32Array(6), nodeU = 0;
            valid.forEach(a => {
                let next = st.clone(); next.apply(a);
                util[a] = this.cfr(next, p, pr * probs[a], w);
                nodeU += probs[a] * util[a];
            });
            valid.forEach(a => {
                let r = util[a] - nodeU;
                node.r[a] += r * w; node.s[a] += (pr * probs[a]) * w;
            });
            return nodeU;
        }
    }
}

/* --- 4. GAME STATE --- */
class State {
    constructor(s0, s1, h1=null, h2=null) {
        if(h1 && h2) this.hands = [h1, h2];
        else { let d=[]; for(let r of RANKS)d.push({r,s:'x'}); this.hands=[d[Math.floor(Math.random()*10)],d[Math.floor(Math.random()*10)]]; }
        this.stacks = [s0-1, s1-1];
        this.bets = [1, 1];
        
        // [FIX] Carried Pot Ï≤òÎ¶¨ Î°úÏßÅ Í∞úÏÑ†
        let carried = window.carriedPot || 0;
        this.pot = 2 + carried;
        this.wasCarried = carried > 0;
        window.carriedPot = 0; // Ï¥àÍ∏∞Ìôî
        
        this.contrib = [1, 1];
        this.hist = [];
        this.turn = 1; this.done = false;
    }

    validActs() {
        let me = this.turn, opp = 1-me;
        if(this.stacks[me]<=0) return [ACT.FOLD, ACT.CHECK];
        let acts = [ACT.FOLD, ACT.CHECK];
        let diff = this.bets[opp] - this.bets[me];
        let target = this.pot + diff;
        for(let a of [2,3,5]) { 
            if(a===ACT.ALLIN) { acts.push(a); continue; }
            let raise = target * MULTS[a];
            if(diff+raise < this.stacks[me] && raise >= 1) acts.push(a);
        }
        return acts;
    }

    apply(a, customAmt = -1) {
        this.hist.push(a);
        if(a===ACT.FOLD) { this.done = true; return; }
        let me = this.turn, opp = 1-me;
        let diff = this.bets[opp] - this.bets[me];
        let amt = 0;

        if (customAmt > 0) {
            amt = Math.min(this.stacks[me], customAmt);
        } else {
            amt = (a===ACT.CHECK) ? Math.min(diff, this.stacks[me]) :
                  (a===ACT.ALLIN) ? this.stacks[me] :
                  Math.min(this.stacks[me], diff + Math.floor((this.pot+diff)*MULTS[a]));
        }
        
        this.stacks[me] -= amt; this.bets[me] += amt; this.contrib[me] += amt; this.pot += amt;
        
        if(this.bets[0]===this.bets[1] && this.hist.length>=1) {
            if(a===ACT.CHECK || a===ACT.FOLD || diff > 0 || (customAmt === diff)) { 
                 if(this.hist.length>=2 || diff>0) this.done = true; 
            }
        }
        if(!this.done) this.turn = opp;
    }

    payoff(p) {
        let opp = 1-p;
        let last = this.hist[this.hist.length-1];
        if(last === ACT.FOLD) {
            let folder = this.turn;
            let penalty = (this.hands[folder].r === 10) ? 10 : 0;
            return (p === (1-folder) ? (this.pot-this.contrib[p]) + penalty : -this.contrib[p] - penalty);
        }
        let r1=this.hands[p].r, r2=this.hands[opp].r;
        if(r1===1 && r2===10) return this.pot-this.contrib[p];
        if(r1===10 && r2===1) return -this.contrib[p];
        if(r1>r2) return this.pot-this.contrib[p];
        if(r1<r2) return -this.contrib[p];
        return 0;
    }
    
    clone() {
        let s = new State(0,0);
        // [FIX] Deep Copy for objects in array
        s.hands = this.hands.map(h => ({...h})); 
        s.stacks=[...this.stacks]; s.bets=[...this.bets];
        s.pot=this.pot; s.contrib=[...this.contrib]; s.hist=[...this.hist]; 
        s.turn=this.turn; s.done=this.done;
        return s;
    }
}

/* --- 5. CONTROLLER --- */
const solver = new Solver();
// [UPDATE] Ïú†Ï†Ä ÏÑ±Ìñ• Î∂ÑÏÑù Í∞ïÌôî (Bluff Detection)
const userStats = { 
    totalHands:0, foldCount:0, 
    bluffOpportunities: 0, // Î∏îÎü¨ÌïëÏù¥ Í∞ÄÎä•Ìïú ÏÉÅÌô©(ÏáºÎã§Ïö¥)
    bluffsDetected: 0,     // Ïã§Ï†ú Î∏îÎü¨Ìïë Í∞êÏßÄ ÌöüÏàò
    getFoldRate: function(){return this.totalHands<1?0:this.foldCount/this.totalHands;},
    getBluffRate: function(){return this.bluffOpportunities<1?0:this.bluffsDetected/this.bluffOpportunities;}
};

let game = null, round = 0, chips = [100, 100];
window.carriedPot = 0;

window.onload = () => {
    shoe.init();
    solver.train(50000, (pct) => { document.getElementById('load-bar').style.width = (pct*100)+'%'; })
          .then(() => { document.getElementById('loading-screen').style.display = 'none'; startRound(); });
};

function log(msg, cls) {
    let div = document.createElement('div'); div.className='log-row '+cls; div.innerText=msg;
    let box = document.getElementById('log-box'); box.appendChild(div); box.scrollTop = box.scrollHeight;
}

function updateUI(showHidden = false) {
    document.getElementById('s-ai').innerText = chips[0].toFixed(0);
    document.getElementById('s-me').innerText = chips[1].toFixed(0);
    
    // [UPDATE] Carried Pot ÏãúÍ∞ÅÌôî
    let potEl = document.getElementById('pot');
    let potBox = document.getElementById('pot-box');
    potEl.innerText = game.pot.toFixed(0);
    if(game.wasCarried && game.pot > 0) {
         potEl.innerText += " (Carried)";
         potBox.classList.add('carried');
    } else {
         potBox.classList.remove('carried');
    }

    document.getElementById('b-ai').innerText = game.bets[0].toFixed(0);
    document.getElementById('b-me').innerText = game.bets[1].toFixed(0);
    
    let c0=game.hands[0], c1=game.hands[1];
    let el0=document.getElementById('c-ai'); el0.innerText=c0.r; el0.className=`card ${['h','d'].includes(c0.s)?'red':'black'}`;
    
    let el1=document.getElementById('c-me'); 
    if(showHidden) { el1.innerText=c1.r; el1.className=`card ${['h','d'].includes(c1.s)?'red':'black'}`; }
    else { el1.innerText="?"; el1.className="card hidden"; }

    let btns = document.querySelectorAll('.controls button');
    let slider = document.getElementById('bet-slider');
    let valid = game.validActs();
    
    btns.forEach(b => b.disabled = true);
    slider.disabled = true;

    if(!game.done && game.turn === 1) {
        let diff = game.bets[0] - game.bets[1];
        document.getElementById('btn-chk').innerText = diff===0 ? "Check" : `Call (${diff})`;
        valid.forEach(v => { 
            let idx = (v===5) ? 5 : (v===0?0: (v===1?1: (v===2?2: (v===3?3: -1))));
            if(idx>=0 && btns[idx]) btns[idx].disabled = false;
        });
        
        let minBet = diff > 0 ? diff : 1;
        let maxBet = game.stacks[1];
        if(maxBet >= minBet) {
            slider.disabled = false;
            slider.min = minBet;
            slider.max = maxBet;
            slider.value = minBet;
            updateSliderBtn();
            document.getElementById('btn-custom').disabled = false;
        }
        document.getElementById('status').innerText = "Your Turn";
    } else {
        document.getElementById('status').innerText = game.done ? "Round Over" : "AI Thinking...";
    }
}

function updateSliderBtn() {
    let val = document.getElementById('bet-slider').value;
    let diff = game.bets[0] - game.bets[1];
    let txt = (parseInt(val) === diff && diff > 0) ? `Call ${val}` : `Bet ${val}`;
    document.getElementById('btn-custom').innerText = txt;
}

function startRound() {
    if(chips[0]<=0 || chips[1]<=0) { alert(chips[0]<=0?"You Win Game!":"You Lose Game!"); return; }
    userStats.totalHands++; round++;
    let h1 = shoe.draw(), h2 = shoe.draw();
    game = new State(chips[0], chips[1], h1, h2);
    
    document.getElementById('ai-thought').style.display = 'none';
    document.getElementById('ai-risk').style.display = 'none';
    document.getElementById('ai-hero').style.display = 'none';
    document.querySelectorAll('.card').forEach(c => { c.classList.remove('winner','loser'); let b=c.querySelector('.badge'); if(b)b.remove(); });
    
    log(`--- Round ${round} ---`, 'l-sys');
    updateUI();
    if(game.turn === 0) runAI();
}

function analyzeHand(oppRank, unknownCards) {
    let wins=0, total=0, tenCount=0;
    for(let c of unknownCards) {
        let myPotentialRank = c.r;
        total++;
        if(myPotentialRank === 10) tenCount++;
        
        if(myPotentialRank===1 && oppRank===10) { wins++; continue; }
        if(myPotentialRank===10 && oppRank===1) continue;
        if(myPotentialRank > oppRank) wins++;
        else if(myPotentialRank === oppRank) wins+=0.5;
    }
    return {
        equity: total===0 ? 0.5 : wins/total,
        probTen: total===0 ? 0 : tenCount/total
    };
}

async function runAI() {
    updateUI(); document.getElementById('ai-thought').style.display='block';
    
    let playerCardRank = game.hands[1].r; 
    let unknownPool = [...shoe.cards, game.hands[0]]; 
    
    let analysis = analyzeHand(playerCardRank, unknownPool);
    let equity = analysis.equity;
    let probTen = analysis.probTen;
    
    document.getElementById('ai-text').innerText = `Win Rate: ${(equity*100).toFixed(0)}% (Pot: ${game.pot})`;
    let bar = document.getElementById('win-rate-bar');
    bar.style.width=(equity*100)+'%';
    bar.style.background = equity>0.6?'#43a047':(equity<0.4?'#e53935':'#fdd835');

    let riskEl = document.getElementById('ai-risk');
    let heroEl = document.getElementById('ai-hero');
    
    // UI ÌëúÏãú Î°úÏßÅ
    if(probTen > 0.1) {
        riskEl.style.display = 'block';
        riskEl.innerText = `‚ö†Ô∏è 10-Risk: ${(probTen*100).toFixed(0)}%`;
    } else riskEl.style.display = 'none';
    
    heroEl.style.display = 'none';

    await new Promise(r=>setTimeout(r, 600+Math.random()*800));

    let key = `Opp:${game.hands[1].r}|Seq:${game.hist.join('')}`;
    let strat = solver.getNode(key).getAvgStrat();
    let valid = game.validActs();

    // 1. Í∏∞Î≥∏ Bias (ÏäπÎ•† Í∏∞Î∞ò)
    let bias = (equity - 0.5) * 2.0;
    if(bias > 0) {
        [ACT.BET_H, ACT.BET_P, ACT.ALLIN].forEach(a => { if(valid.includes(a)) strat[a]*=(1+bias*1.5); });
        if(valid.includes(ACT.FOLD)) strat[ACT.FOLD]*=(1-bias*0.8);
    } else {
        let def = Math.abs(bias);
        if(valid.includes(ACT.FOLD)) strat[ACT.FOLD]*=(1+def*2.0);
        [ACT.BET_H, ACT.BET_P, ACT.ALLIN].forEach(a => { if(valid.includes(a)) strat[a]*=(1-def*0.8); });
    }

    // 2. [UPDATE] Î≥¥ÏàòÏ†ÅÏù∏ 10 Ìå®ÎÑêÌã∞ ÌöåÌîº Î°úÏßÅ
    // 10Ïùº ÌôïÎ•† 10% ÎØ∏ÎßåÏù¥Î©¥ Î¨¥Ïãú. Í∑∏ Ïù¥ÏÉÅÏùº ÎïåÎßå ÏÑ†ÌòïÏ†ÅÏúºÎ°ú Ìè¥Îìú ÌôïÎ•† Í∞êÏÜå.
    // ÏµúÎåÄ Í∞êÏÜåÌè≠ 80% (Ïù¥Ï†ÑÏóêÎäî 100%Ïó¨ÏÑú Ï†àÎåÄ Ïïà Ï£ΩÏùå)
    if (probTen > 0.1 && valid.includes(ACT.FOLD)) {
        let penaltyFactor = Math.min(Math.max(probTen - 0.1, 0) * 2.5, 0.8);
        
        let foldProb = strat[ACT.FOLD];
        let reduceAmount = foldProb * penaltyFactor; 
        
        strat[ACT.FOLD] -= reduceAmount;
        let safeOption = valid.includes(ACT.CHECK) ? ACT.CHECK : 
                         (valid.includes(ACT.BET_H) ? ACT.BET_H : -1);
        if(safeOption !== -1) strat[safeOption] += reduceAmount;
        strat[ACT.FOLD] = Math.max(strat[ACT.FOLD], 0.05); // ÏµúÏÜå 5%Îäî ÎÇ®ÍπÄ
    }

    // 3. [UPDATE] Hero Call (Î∏îÎü¨Ìïë Ï∫êÏπò)
    let bluffRate = userStats.getBluffRate();
    if (bluffRate > 0.25 && equity > 0.35 && equity < 0.65) {
        if(valid.includes(ACT.FOLD) && valid.includes(ACT.CHECK)) {
            
            // [ÏàòÏ†ï] Î∏îÎü¨ÌîÑ ÏÑ±Ìñ•Ïù¥ 40%Î•º ÎÑòÎäî 'ÏäµÍ¥ÄÏ†Å Îª•Ïπ¥Íæº'Ïù¥Î©¥ 80% ÌôïÎ•†Î°ú ÏΩú Ï†ÑÌôò
            // Í∑∏ Ï†ïÎèÑÎäî ÏïÑÎãàÎ©¥ 50%Îßå Ï†ÑÌôò (Î≥¥ÏàòÏ†Å Ï†ëÍ∑º)
            let factor = (bluffRate > 0.4) ? 0.7 : 0.5; 
            
            let shift = strat[ACT.FOLD] * factor; 
            
            strat[ACT.FOLD] -= shift;
            strat[ACT.CHECK] += shift;
            
            heroEl.style.display = 'block';
            heroEl.innerText = `üëÅÔ∏è Hero Call Mode (Bluff: ${(bluffRate*100).toFixed(0)}%)`;
        }
    }

    // 4. ÏÇ¨Ïö©Ïûê Ìè¥Îìú ÏÑ±Ìñ• ÎåÄÏùë (Í∏∞Ï°¥ Î°úÏßÅ Ïú†ÏßÄ)
    if (userStats.totalHands >= 5) {
        let diff = userStats.getFoldRate() - 0.4;
        let mult = Math.min(Math.max(1.0 + (diff*0.5), 0.6), 1.5);
        [ACT.BET_H, ACT.BET_P, ACT.ALLIN].forEach(a => { if(valid.includes(a)) strat[a] *= mult; });
    }

    let vSum=0; valid.forEach(a=>vSum+=strat[a]);
    let action = valid.includes(ACT.CHECK)?ACT.CHECK:ACT.FOLD;
    if(vSum>0) {
        let r=Math.random(), cum=0;
        for(let a of valid) { cum+=strat[a]/vSum; if(r<=cum){action=a; break;} }
    }

    log(`ü§ñ AI: ${ACT_TXT[action]}`, 'l-ai');
    game.apply(action);
    if(game.done) endRound(); else updateUI();
}

function act(a) {
    if(game.turn!==1) return;
    if(a===ACT.FOLD) userStats.foldCount++;
    log(`üë§ You: ${ACT_TXT[a]}`, 'l-user');
    game.apply(a);
    if(game.done) endRound(); else runAI();
}

function actCustom() {
    if(game.turn!==1) return;
    let val = parseInt(document.getElementById('bet-slider').value);
    let diff = game.bets[0] - game.bets[1];
    
    let pot = game.pot + diff;
    let ratio = val / pot;
    let aiAct = ACT.BET_P; 
    if (val === game.stacks[1]) aiAct = ACT.ALLIN;
    else if (val <= diff) aiAct = ACT.CHECK;
    else if (ratio < 0.4) aiAct = ACT.BET_H;
    else if (ratio < 1.2) aiAct = ACT.BET_P; 
    else aiAct = ACT.BET_O;

    let txt = (val === diff && diff > 0) ? "Call" : "Bet";
    log(`üë§ You: ${txt} ${val} (Custom)`, 'l-user');
    
    game.apply(aiAct, val);
    if(game.done) endRound(); else runAI();
}

function endRound() {
    updateUI(true); // Ïπ¥Îìú Í≥µÍ∞ú

    // 1. ÏäπÌå® ÌåêÏ†ï
    let r0 = game.hands[0].r, r1 = game.hands[1].r;
    let winner = -1; // -1: Î¨¥ÏäπÎ∂Ä, 0: AI Ïäπ, 1: ÌîåÎ†àÏù¥Ïñ¥ Ïäπ
    let last = game.hist[game.hist.length-1];

    if(last === ACT.FOLD) {
        winner = 1 - game.turn; // Ìè¥ÎìúÌïú ÏÇ¨ÎûåÏùò Î∞òÎåÄÌé∏Ïù¥ ÏäπÎ¶¨
    } else {
        // ÏáºÎã§Ïö¥ ÌåêÏ†ï (ÌòÅÎ™Ö Ìè¨Ìï®)
        if((r0===1 && r1===10)) winner = 0;      // AI ÌòÅÎ™Ö Ïäπ
        else if((r0===10 && r1===1)) winner = 1; // ÌîåÎ†àÏù¥Ïñ¥ ÌòÅÎ™Ö Ïäπ
        else if(r0 > r1) winner = 0;
        else if(r1 > r0) winner = 1;
    }

    // 2. Ïπ© Ï†ïÏÇ∞ (ÏÇ¨Ïù¥Îìú Ìåü Î°úÏßÅ Ï†ÅÏö©)
    // ÏùºÎã® ÌåêÎèàÏùÑ Îã§ Í±∑Ïñ¥Í∞îÎã§Í≥† Í∞ÄÏ†ïÌïòÍ≥† ÏãúÏûë
    chips[0] -= game.contrib[0];
    chips[1] -= game.contrib[1];

    // Ï¥àÍ≥º Î≤†ÌåÖÍ∏à(Excess) Í≥ÑÏÇ∞: Îçî ÎßéÏù¥ Î≤†ÌåÖÌïú ÏÇ¨ÎûåÏóêÍ≤å Ï¶âÏãú ÌôòÎ∂à
    let excess = Math.abs(game.contrib[0] - game.contrib[1]);
    if(game.contrib[0] > game.contrib[1]) chips[0] += excess;
    else chips[1] += excess;

    // Ïã§Ï†ú ÏäπÎ∂Ä Ìåü (Ï¥àÍ≥ºÍ∏àÏùÑ Ï†úÏô∏Ìïú Í∏àÏï° + Ïù¥ÏõîÎêú ÌåüÏù¥ ÏûàÎã§Î©¥ Ìè¨Ìï®)
    let mainPot = game.pot - excess;

    let aiCard = document.getElementById('c-ai');
    let myCard = document.getElementById('c-me');

    // 3. Í≤∞Í≥º Ï≤òÎ¶¨ Î∞è Î∞∞ÏßÄ Î∂ÄÏ∞©
    // [Ìè¥Îìú Ìå®ÎÑêÌã∞ Ï≤¥ÌÅ¨]
    if(last === ACT.FOLD) {
        let folder = game.turn;
        if(game.hands[folder].r === 10) {
            addBadge(folder===0?aiCard:myCard, "-10 PENALTY", 'bg-pen');
            log("üö® 10-Holding Penalty!", "l-warn");
            // Ìå®ÎÑêÌã∞Îäî Ìåü Í≥ÑÏÇ∞Í≥º Î≥ÑÍ∞úÎ°ú Í≤åÏûÑ Ï¢ÖÎ£å ÌõÑ Ï∞®Í∞êÌïòÍ±∞ÎÇò Íµ¨ÌòÑ Î∞©ÏãùÏóê Îî∞Îùº Îã§Î•¥ÏßÄÎßå,
            // Ïó¨Í∏∞ÏÑúÎäî 10ÏùÑ Îì§Í≥† Ï£ΩÏùÄ Í≤ÉÏù¥ Î∞úÍ∞ÅÎêú Í≤ÉÎßå ÌëúÏãúÌï©ÎãàÎã§.
        }
    } else {
        // [ÌòÅÎ™Ö Î∞∞ÏßÄ]
        if( (r0===1 && r1===10) || (r0===10 && r1===1) ) {
            log("‚ö° REVOLUTION! (1 > 10)", "l-warn");
            addBadge(winner===0?aiCard:myCard, "1 > 10 WIN", 'bg-rev');
        }
    }

    // [Î∏îÎü¨Ìïë Í∞êÏßÄ Î°úÏßÅ]
    if(last !== ACT.FOLD && winner === 0 && r1 <= 6 && game.contrib[1] > 10) {
         userStats.bluffOpportunities++;
         userStats.bluffsDetected++;
         log(`üïµÔ∏è Bluff Detected! (Rank ${r1})`, 'l-sys');
    } else if (last !== ACT.FOLD && winner === 0) {
         userStats.bluffOpportunities++;
    }

    // 4. Ìåü Î∂ÑÎ∞∞
    if(winner === 0) { // AI ÏäπÎ¶¨
        log(`üíÄ LOSE (-${(mainPot - game.contrib[0]).toFixed(0)})`, 'l-ai');
        aiCard.classList.add('winner'); myCard.classList.add('loser');
        chips[0] += mainPot;
        window.carriedPot = 0;
    } 
    else if(winner === 1) { // ÌîåÎ†àÏù¥Ïñ¥ ÏäπÎ¶¨
        log(`üéâ WIN (+${(mainPot - game.contrib[1]).toFixed(0)})`, 'l-user');
        myCard.classList.add('winner'); aiCard.classList.add('loser');
        chips[1] += mainPot;
        window.carriedPot = 0;
    } 
    else { // Î¨¥ÏäπÎ∂Ä
        log(`ü§ù DRAW - Pot (${mainPot}) Carried Over!`, 'l-sys');
        window.carriedPot = mainPot;
        // Î¨¥ÏäπÎ∂Ä Ïãú Ïπ©ÏùÄ ÎèåÎ†§Ï£ºÏßÄ ÏïäÍ≥† Îã§Ïùå Ìåê ÌåüÏúºÎ°ú Ïù¥Ïõî (chipsÏóêÎäî ÎçîÌïòÏßÄ ÏïäÏùå)
    }

    setTimeout(startRound, 2500);
}

function addBadge(el, txt, cls) {
    let b = document.createElement('div'); b.className = 'badge '+cls; b.innerText = txt; el.appendChild(b);
}
</script>
</body>
</html>

