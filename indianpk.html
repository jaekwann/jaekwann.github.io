<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Indian Hold'em (Async Training)</title>
    <style>
        :root {
            --bg-color: #2c3e50;
            --table-color: #27ae60;
            --card-bg: #ecf0f1;
            --text-color: #ffffff;
            --accent-color: #f1c40f;
            --btn-color: #3498db;
        }
        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
        }
        .container {
            width: 100%;
            max-width: 500px;
            background-color: #34495e;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
            position: relative;
        }
        
        /* Loading Overlay */
        #loading-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(44, 62, 80, 0.98);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        .spinner {
            border: 4px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top: 4px solid var(--accent-color);
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        #progress-container {
            width: 80%;
            height: 20px;
            background: #555;
            border-radius: 10px;
            margin-top: 15px;
            overflow: hidden;
            position: relative;
        }
        #progress-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #f1c40f, #e67e22);
            transition: width 0.2s;
        }
        #loading-text { font-weight: bold; margin-top: 10px; text-align: center; }

        /* Game Header */
        .header { background: #2c3e50; padding: 15px; text-align: center; border-bottom: 2px solid #1abc9c; }
        .stats-row { display: flex; justify-content: space-around; font-weight: bold; font-size: 1.1em; }
        
        /* Table */
        .table { background: var(--table-color); padding: 20px; min-height: 380px; text-align: center; position: relative; }
        
        .card-area { display: flex; justify-content: space-between; margin: 15px 0; }
        .player-box { background: rgba(0,0,0,0.3); border-radius: 10px; padding: 10px; width: 45%; }
        
        .card {
            background: var(--card-bg); color: #333; width: 60px; height: 90px;
            border-radius: 6px; display: inline-flex; justify-content: center; align-items: center;
            font-size: 1.8em; font-weight: bold; margin-top: 5px; box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
        }
        .card.red { color: #c0392b; }
        .card.black { color: #2c3e50; }
        .card.hidden { background: #7f8c8d; color: #bdc3c7; }

        .pot-display { background: rgba(0,0,0,0.5); padding: 5px 15px; border-radius: 15px; display: inline-block; font-weight: bold; color: var(--accent-color); margin-bottom: 10px;}

        /* AI Visualization */
        .ai-thought {
            background: #fff; color: #333; border-radius: 8px; padding: 10px;
            width: 90%; margin: 0 auto 10px auto; font-size: 0.85em; display: none;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            position: relative; text-align: left;
        }
        .ai-thought::after {
             content: ''; position: absolute; top: -8px; left: 20%;
             border-width: 0 8px 8px 8px; border-style: solid; border-color: transparent transparent #fff transparent;
        }
        .bar-container { display: flex; height: 10px; margin-top: 4px; border-radius: 5px; overflow: hidden; background: #ddd; }
        .bg-red { background: #e74c3c; } .bg-yellow { background: #f1c40f; } .bg-green { background: #2ecc71; }
        
        /* Typing Animation */
        .typing span { display: inline-block; width: 4px; height: 4px; background: #333; border-radius: 50%; animation: type 1s infinite; margin: 0 2px; }
        .typing span:nth-child(2) { animation-delay: 0.2s; } .typing span:nth-child(3) { animation-delay: 0.4s; }
        @keyframes type { 0%,100%{transform:translateY(0);} 50%{transform:translateY(-4px);} }

        /* Controls */
        .controls { padding: 15px; background: #34495e; display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        button { padding: 12px; border: none; border-radius: 8px; color: white; cursor: pointer; font-weight: bold; font-size: 1em; transition: 0.1s; }
        button:active { transform: scale(0.96); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-fold { background: #e74c3c; grid-column: span 2; }
        .btn-check { background: #27ae60; grid-column: span 2; }
        .btn-bet { background: #3498db; }
        .btn-allin { background: #8e44ad; }

        .logs { height: 130px; overflow-y: auto; background: #222; color: #ccc; font-size: 0.85em; padding: 10px; border-top: 1px solid #444; text-align: left; }
        .log-entry { border-bottom: 1px solid #333; padding-bottom: 2px; margin-bottom: 2px; }
        .log-ai { color: #f39c12; } .log-user { color: #3498db; } .log-sys { color: #95a5a6; font-style: italic; }
    </style>
</head>
<body>

<div class="container">
    <div id="loading-overlay">
        <div class="spinner"></div>
        <div id="loading-text">Starting AI Training...<br>0%</div>
        <div id="progress-container"><div id="progress-bar"></div></div>
    </div>

    <div class="header">
        <div class="stats-row">
            <span>ü§ñ AI: <span id="ai-stack">100.0</span></span>
            <span>R<span id="round-num">1</span></span>
            <span>üë§ You: <span id="my-stack">100.0</span></span>
        </div>
    </div>

    <div class="table">
        <div class="ai-thought" id="ai-thought-box">
            <div id="ai-msg">Thinking...</div>
            <div style="margin-top:5px; color:#666; font-size:0.9em;">AI's Guess on ITS OWN card:</div>
            <div class="bar-container" id="belief-bar">
                <div class="bg-red" style="width:33%"></div>
                <div class="bg-yellow" style="width:33%"></div>
                <div class="bg-green" style="width:33%"></div>
            </div>
            <div style="display:flex; justify-content:space-between; font-size:0.75em; color:#888;">
                <span>Low</span><span>Mid</span><span>High</span>
            </div>
        </div>

        <div class="card-area">
            <div class="player-box">
                <div>AI (Bet: <span id="ai-bet">0</span>)</div>
                <div class="card" id="ai-card">?</div>
            </div>
            <div class="player-box">
                <div>You (Bet: <span id="my-bet">0</span>)</div>
                <div class="card hidden" id="my-card">?</div>
            </div>
        </div>

        <div class="pot-display">Pot: <span id="pot-size">2.0</span></div>
        <div id="game-status" style="color:#bdc3c7; font-size:0.9em; margin-top:5px;">Game Start</div>
    </div>

    <div class="controls">
        <button class="btn-fold" onclick="humanAction(0)">Fold</button>
        <button class="btn-check" id="btn-check" onclick="humanAction(1)">Check</button>
        <button class="btn-bet" id="btn-bet1" onclick="humanAction(2)">Bet Small (33%)</button>
        <button class="btn-bet" id="btn-bet2" onclick="humanAction(3)">Bet Large (75%)</button>
        <button class="btn-bet" id="btn-bet3" onclick="humanAction(4)">Overbet (150%)</button>
        <button class="btn-allin" onclick="humanAction(5)">All-In</button>
    </div>

    <div class="logs" id="log-box"></div>
</div>

<script>
/** * Indian Hold'em AI (Async Training Version)
 * Doesn't freeze the browser!
 */

// --- CONFIG ---
const RANKS = [1,2,3,4,5,6,7,8,9,10];
const SUITS = ['s','h','d','c'];
const SYMBOLS = {'s':'‚ô†','h':'‚ô•','d':'‚ô¶','c':'‚ô£'};
const ACT = { FOLD:0, CHECK:1, BET_S:2, BET_L:3, BET_O:4, ALLIN:5 };
const ACT_NAMES = ["Fold", "Check/Call", "Bet Small", "Bet Large", "Overbet", "All-In"];
const BET_MULTS = { 2:0.33, 3:0.75, 4:1.5, 5:999.0 };

// --- HELPERS ---
function delay(ms) { return new Promise(r => setTimeout(r, ms)); }
// This function yields control back to the UI thread
function nextFrame() { return new Promise(r => setTimeout(r, 0)); }

function weightedChoice(probs) {
    let r = Math.random(), sum = 0;
    for(let i=0; i<probs.length; i++) {
        sum += probs[i];
        if(r <= sum) return i;
    }
    return probs.length-1;
}

// --- AI ENGINE (MCCFR) ---
class Node {
    constructor(n) { 
        this.regret = new Float32Array(n); 
        this.strategy = new Float32Array(n); 
    }
    getStrategy() {
        let r = this.regret.map(v => Math.max(v, 0));
        let sum = r.reduce((a,b)=>a+b, 0);
        return sum > 0 ? r.map(v => v/sum) : r.map(()=>1/this.regret.length);
    }
    getAvgStrategy() {
        let sum = this.strategy.reduce((a,b)=>a+b, 0);
        return sum > 0 ? this.strategy.map(v => v/sum) : this.strategy.map(()=>1/this.strategy.length);
    }
}

class Solver {
    constructor() { this.nodes = {}; }
    getNode(key) { if(!this.nodes[key]) this.nodes[key] = new Node(6); return this.nodes[key]; }
    
    // ÎπÑÎèôÍ∏∞ ÌïôÏäµ Ìï®Ïàò (Î©àÏ∂§ Î∞©ÏßÄ)
    async train(iters, onProgress) {
        const BATCH_SIZE = 200; // 200Ìåê Í≥ÑÏÇ∞ÌïòÍ≥† ÌôîÎ©¥ Í∞±Ïã†
        
        for(let i=0; i<iters; i+=BATCH_SIZE) {
            
            // BATCH_SIZEÎßåÌÅº Îπ°ÏÑ∏Í≤å Í≥ÑÏÇ∞
            for(let j=0; j<BATCH_SIZE && (i+j)<iters; j++) {
                let s0 = Math.floor(Math.random()*180)+20;
                let s1 = Math.floor(Math.random()*180)+20;
                let state = new State(s0, s1);
                state.turn = Math.random()<0.5 ? 0 : 1;
                this.cfr(state, (i+j)%2, 1.0);
            }
            
            // ÌôîÎ©¥ Í∞±Ïã†ÏùÑ ÏúÑÌï¥ Ïû†Íπê Ïâº (Yield)
            if(onProgress) onProgress((i+BATCH_SIZE)/iters);
            await nextFrame(); 
        }
    }

    cfr(state, p, pr) {
        if(state.done) return state.getPayoff(p);

        let valid = state.validActions();
        if(valid.length===0) return 0;

        let key = `Opp:${state.hands[1-state.turn].r}|Seq:${state.hist.join('')}`;
        let node = this.getNode(key);
        let strat = node.getStrategy();
        
        let probs = new Float32Array(6);
        let sum = 0;
        valid.forEach(a => { probs[a] = strat[a]; sum += strat[a]; });
        if(sum > 0) probs = probs.map(v => v/sum);
        else valid.forEach(a => probs[a] = 1.0/valid.length);

        if(state.turn !== p) {
            let a = weightedChoice(probs);
            if(!valid.includes(a)) a = valid[Math.floor(Math.random()*valid.length)];
            let next = state.clone(); next.apply(a);
            return this.cfr(next, p, pr);
        } else {
            let util = new Float32Array(6);
            let nodeUtil = 0;
            valid.forEach(a => {
                let next = state.clone(); next.apply(a);
                util[a] = this.cfr(next, p, pr * probs[a]);
                nodeUtil += probs[a] * util[a];
            });
            valid.forEach(a => {
                node.regret[a] += util[a] - nodeUtil;
                node.strategy[a] += pr * probs[a];
            });
            return nodeUtil;
        }
    }
}

class State {
    constructor(s0, s1) {
        this.deck = [];
        for(let r of RANKS) for(let s of SUITS) this.deck.push({r,s});
        for(let i=39; i>0; i--) { let j=Math.floor(Math.random()*(i+1)); [this.deck[i],this.deck[j]]=[this.deck[j],this.deck[i]]; }
        
        this.stacks = [s0-1, s1-1];
        this.bets = [1, 1];
        this.pot = 2;
        this.contrib = [1, 1];
        this.hands = [this.deck.pop(), this.deck.pop()];
        this.hist = [];
        this.turn = 1; // Human first
        this.done = false;
    }
    
    validActions() {
        let me = this.turn, opp = 1-me;
        if(this.stacks[me]<=0) return [ACT.FOLD, ACT.CHECK];
        if(this.stacks[opp]<=0 && this.bets[opp]>this.bets[me]) return [ACT.FOLD, ACT.CHECK];
        
        let acts = [ACT.FOLD, ACT.CHECK];
        let diff = this.bets[opp] - this.bets[me];
        let target = this.pot + diff;
        
        if(!this.done) {
            for(let a of [2,3,4,5]) {
                if(a===ACT.ALLIN) { acts.push(a); continue; }
                let raise = target * BET_MULTS[a];
                if((diff + raise) < this.stacks[me] && raise >= 1) acts.push(a);
            }
        }
        return acts;
    }

    apply(a) {
        this.hist.push(a);
        let me = this.turn, opp = 1-me;
        if(a===ACT.FOLD) { this.done = true; return; }
        
        let diff = this.bets[opp] - this.bets[me];
        let amt = 0;
        
        if(a===ACT.CHECK) amt = Math.min(diff, this.stacks[me]);
        else if(a===ACT.ALLIN) amt = this.stacks[me];
        else {
            let raise = (this.pot + diff) * BET_MULTS[a];
            amt = diff + raise;
            if(amt > this.stacks[me]) amt = this.stacks[me];
        }
        
        this.stacks[me] -= amt;
        this.bets[me] += amt;
        this.contrib[me] += amt;
        this.pot += amt;
        
        if(a===ACT.CHECK && this.bets[0]===this.bets[1] && this.hist.length>=1) {
             if(this.hist.length>=2 || diff>0) this.done = true;
        }
        if(!this.done) this.turn = opp;
    }
    
    getPayoff(p) {
        let opp = 1-p;
        if(this.hist[this.hist.length-1] === ACT.FOLD) {
            if(this.turn === p) return -this.contrib[p];
            else return this.pot - this.contrib[p];
        }
        let r1 = this.hands[p].r, r2 = this.hands[opp].r;
        if(r1 > r2) return this.pot - this.contrib[p];
        if(r1 < r2) return -this.contrib[p];
        return this.pot/2 - this.contrib[p];
    }
    
    clone() {
        let s = new State(0,0);
        s.deck = [...this.deck]; s.stacks=[...this.stacks]; s.bets=[...this.bets];
        s.pot=this.pot; s.contrib=[...this.contrib]; s.hands=[...this.hands];
        s.hist=[...this.hist]; s.turn=this.turn; s.done=this.done;
        return s;
    }
}

// --- UI & MAIN ---
let solver = new Solver();
let aiChips = 100, myChips = 100;
let game = null, round = 0;

window.onload = function() {
    let bar = document.getElementById('progress-bar');
    let txt = document.getElementById('loading-text');
    
    // Start Async Training
    // 10,000 Iterations is enough for Indian Hold'em (small state space)
    solver.train(10000, (pct) => {
        let p = Math.min(100, Math.floor(pct*100));
        bar.style.width = p + '%';
        txt.innerHTML = `Training AI... ${p}%<br><span style="font-size:0.8em; font-weight:normal;">Calculated ${Math.floor(pct*10000)} hands</span>`;
    }).then(() => {
        document.getElementById('loading-overlay').style.display = 'none';
        startRound();
    });
};

function log(msg, cls) {
    let div = document.createElement('div');
    div.innerText = msg; div.className = 'log-entry '+cls;
    let box = document.getElementById('log-box');
    box.appendChild(div); box.scrollTop = box.scrollHeight;
}

function updateUI() {
    document.getElementById('ai-stack').innerText = game.stacks[0].toFixed(1);
    document.getElementById('my-stack').innerText = game.stacks[1].toFixed(1);
    document.getElementById('pot-size').innerText = game.pot.toFixed(1);
    document.getElementById('ai-bet').innerText = game.bets[0].toFixed(1);
    document.getElementById('my-bet').innerText = game.bets[1].toFixed(1);
    document.getElementById('round-num').innerText = round;

    let aiC = game.hands[0];
    let el0 = document.getElementById('ai-card');
    el0.innerText = aiC.r + SYMBOLS[aiC.s];
    el0.className = `card ${['h','d'].includes(aiC.s)?'red':'black'}`;
    
    let el1 = document.getElementById('my-card');
    if(game.done) {
        let myC = game.hands[1];
        el1.innerText = myC.r + SYMBOLS[myC.s];
        el1.className = `card ${['h','d'].includes(myC.s)?'red':'black'}`;
    } else {
        el1.innerText = "?"; el1.className = "card hidden";
    }

    let btns = document.querySelectorAll('.controls button');
    let valid = game.validActions();
    btns.forEach(b => b.disabled = true);
    
    if(!game.done && game.turn === 1) {
        let diff = Math.max(0, game.bets[0] - game.bets[1]);
        document.getElementById('btn-check').innerText = diff===0 ? "Check" : `Call (${diff.toFixed(1)})`;
        if(valid.includes(ACT.FOLD)) btns[0].disabled = false;
        if(valid.includes(ACT.CHECK)) btns[1].disabled = false;
        if(valid.includes(ACT.BET_S)) btns[2].disabled = false;
        if(valid.includes(ACT.BET_L)) btns[3].disabled = false;
        if(valid.includes(ACT.BET_O)) btns[4].disabled = false;
        if(valid.includes(ACT.ALLIN)) btns[5].disabled = false;
    }
}

function startRound() {
    if(aiChips<=0 || myChips<=0) { 
        alert(aiChips<=0 ? "You Win!" : "You Lose!");
        return; 
    }
    round++;
    game = new State(aiChips, myChips);
    log(`--- Round ${round} ---`, 'log-sys');
    document.getElementById('ai-thought-box').style.display = 'none';
    updateUI();
    if(game.turn === 0) runAI();
}

async function runAI() {
    updateUI();
    document.getElementById('ai-thought-box').style.display = 'block';
    
    // AI Thought Visualization
    let belief = new Float32Array(11).fill(1);
    game.hist.forEach(a => {
        if(a===ACT.CHECK) { for(let i=1;i<=5;i++) belief[i]*=0.7; for(let i=6;i<=10;i++) belief[i]*=1.3; }
        else if(a>=ACT.BET_S) { for(let i=1;i<=5;i++) belief[i]*=1.5; for(let i=6;i<=10;i++) belief[i]*=0.6; }
    });
    let sum=0; for(let i=1;i<=10;i++) sum+=belief[i];
    let low=0, mid=0, high=0;
    for(let i=1;i<=5;i++) low+=belief[i];
    for(let i=6;i<=8;i++) mid+=belief[i];
    for(let i=9;i<=10;i++) high+=belief[i];
    
    let bars = document.getElementById('belief-bar').children;
    bars[0].style.width = (low/sum*100)+'%';
    bars[1].style.width = (mid/sum*100)+'%';
    bars[2].style.width = (high/sum*100)+'%';
    
    let msg = document.getElementById('ai-msg');
    msg.innerHTML = 'Thinking<span class="typing"><span></span><span></span><span></span></span>';
    
    await delay(1500);
    
    let key = `Opp:${game.hands[1].r}|Seq:${game.hist.join('')}`;
    let node = solver.getNode(key);
    let strat = node.getAvgStrategy();
    let valid = game.validActions();
    
    let probs = [], pSum = 0;
    valid.forEach(a => { probs.push(strat[a]); pSum+=strat[a]; });
    if(pSum>0) probs = probs.map(p=>p/pSum);
    else probs = probs.map(()=>1/valid.length);
    
    let choiceIdx = weightedChoice(probs);
    let action = valid[choiceIdx];
    
    log("ü§ñ AI: " + ACT_NAMES[action], 'log-ai');
    msg.innerText = "I choose: " + ACT_NAMES[action];
    game.apply(action);
    
    if(game.done) endRound();
    else updateUI();
}

function humanAction(a) {
    if(game.turn !== 1) return;
    log("üë§ You: " + ACT_NAMES[a], 'log-user');
    game.apply(a);
    if(game.done) endRound();
    else runAI();
}

function endRound() {
    updateUI();
    let p = game.getPayoff(1);
    myChips += p; aiChips -= p;
    setTimeout(() => {
        if(p>0) log(`üéâ You Won ${p.toFixed(1)}`, 'log-sys');
        else if(p<0) log(`üíÄ You Lost ${Math.abs(p).toFixed(1)}`, 'log-sys');
        else log(`ü§ù Tie`, 'log-sys');
        setTimeout(startRound, 2000);
    }, 500);
}
</script>
</body>
</html>

