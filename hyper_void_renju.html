<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Hyper Void Renju</title>
</head>
<body>

Â  Â  <div id="hyper_container" style="text-align: center; background: radial-gradient(circle at center, #0b1a0b 0%, #000000 100%); padding: 20px; border-radius: 25px; border: 4px solid #55ff55; box-shadow: 0 0 80px rgba(85, 255, 85, 0.15); color: #fff; font-family: 'Fira Code', monospace; max-width: 720px; margin: auto;">
Â  Â  Â  Â  <h1 style="color: #55ff55; margin: 0 0 5px 0; text-shadow: 0 0 25px #55ff55; letter-spacing: 4px; font-size: 28px;">HYPER-VOID: [V9.9 INTEGRITY]</h1>
Â  Â  Â  Â  <div style="font-size: 11px; color: #ccffcc; margin-bottom: 15px; letter-spacing: 1px;">FULL BOUNDARY LOGIC | DIAG THREAT FIX | FINAL</div>
Â  Â  Â  Â Â 
Â  Â  Â  Â  <div style="display: flex; justify-content: space-between; align-items: center; background: rgba(10,30,10,0.8); padding: 12px 20px; border-radius: 12px; margin-bottom: 15px; border: 1px solid #44aa44;">
Â  Â  Â  Â  Â  Â  <div style="text-align: left; font-size: 13px; color: #e0e0e0;">
Â  Â  Â  Â  Â  Â  Â  Â  <div>ğŸ® <b>YOU:</b> <span id="u_role" style="color:#fff; font-weight:bold;">BLACK (First)</span></div>
Â  Â  Â  Â  Â  Â  Â  Â  <div>ğŸ›¡ï¸ <b>AI:</b> <span id="a_role" style="color:#ccc; font-weight:bold;">WHITE (Second)</span></div>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  Â  Â  <div id="v_stats" style="text-align: right; font-size: 12px; color: #88ff88;">
Â  Â  Â  Â  Â  Â  Â  Â  <div>MODE: <b id="s_mode">READY</b></div>
Â  Â  Â  Â  Â  Â  Â  Â  <div>NODES: <b id="s_nodes">0</b> | DEPTH: <b id="s_depth">0</b></div>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>

Â  Â  Â  Â  <div style="position: relative; display: inline-block; width: 100%; max-width: 600px;">
Â  Â  Â  Â  Â  Â  <canvas id="vBoard" width="600" height="600" style="width: 100%; height: auto; cursor: none; background: #051a05; border-radius: 4px; box-shadow: 0 20px 60px rgba(0,0,0,1); border: 1px solid #004400;"></canvas>
Â  Â  Â  Â  </div>

Â  Â  Â  Â  <div id="v_status" style="margin-top: 15px; font-size: 16px; font-weight: bold; color: #fff; min-height: 24px; text-shadow: 0 0 10px rgba(255,255,255,0.3);"></div>
Â  Â  Â  Â  <div id="v_forbidden" style="margin-top: 5px; font-size: 13px; color: #ff4444; font-weight: bold; min-height: 20px;"></div>
Â  Â  Â  Â Â 
Â  Â  Â  Â  <div style="margin-top: 20px; display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;">
Â  Â  Â  Â  Â  Â  <button onclick="swapSides()" style="padding: 10px 20px; background: #113311; color: #fff; border: 1px solid #227722; font-weight: bold; cursor: pointer; border-radius: 6px; transition: 0.2s;">ğŸ”„ SWAP</button>
Â  Â  Â  Â  Â  Â  <button onclick="resetVoid()" style="padding: 10px 20px; background: linear-gradient(90deg, #44cc44, #228822); color: #fff; border: none; font-weight: bold; cursor: pointer; border-radius: 6px; box-shadow: 0 0 20px rgba(68, 204, 68, 0.4);">ğŸš€ REBOOT</button>
Â  Â  Â  Â  Â  Â  <button onclick="undoMove()" style="padding: 10px 20px; background: #114411; color: #ccc; border: none; font-weight: bold; cursor: pointer; border-radius: 6px;">â†¶ UNDO</button>
Â  Â  Â  Â  Â  Â  <button onclick="requestHint()" id="hintBtn" style="padding: 10px 20px; background: #d900ff; color: #fff; border: none; font-weight: bold; cursor: pointer; border-radius: 6px; box-shadow: 0 0 15px rgba(217,0,255,0.4);">ğŸ’¡ HINT</button>
Â  Â  Â  Â  </div>
Â  Â  </div>

Â  Â  <script>
Â  Â  (function() {
Â  Â  Â  Â  const workerSource = `
Â  Â  Â  Â  const INF = 1000000000;Â 
Â  Â  Â  Â  let nodes = 0;
Â  Â  Â  Â  let mctsSims = 0;
Â  Â  Â  Â  let startTime = 0;
Â  Â  Â  Â  const TIME_LIMIT = 2000;Â 
Â  Â  Â  Â  const MAX_TT_SIZE = 5000000;Â 
Â  Â  Â  Â Â 
Â  Â  Â  Â  // [BOOK LOGIC KEPT SAME]
Â  Â  Â  Â  const BOOK = {
Â  Â  Â  Â  Â  Â  "7,7|6,8|6,6": {r:5, c:7}, "7,7|6,8|6,6|5,7": {r:5, c:8},Â 
Â  Â  Â  Â  Â  Â  "7,7|6,6|8,6": {r:5, c:5}, "7,7|6,6|8,8": {r:5, c:5},Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  "7,7|7,8|6,8": {r:5, c:7}, "7,7|7,8|6,8|5,7": {r:5, c:8},
Â  Â  Â  Â  Â  Â  "7,7|5,6|4,5": {r:3, c:6}, "7,7|6,9|5,10": {r:4, c:9},Â  Â  Â 
Â  Â  Â  Â  Â  Â  "7,7|9,6|10,5": {r:8, c:4}, "7,7|5,8|4,9": {r:3, c:8},Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  "7,7|6,7|6,6": {r:5, c:5}, "7,7|8,7|8,6": {r:9, c:5},Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  "7,7|8,7|8,6|9,5": {r:7, c:5}, "7,7|7,5|6,4": {r:5, c:5},Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  "7,7|5,7|4,6": {r:3, c:7}, "7,7|5,7|4,6|3,7": {r:5, c:5},
Â  Â  Â  Â  Â  Â  "7,7|5,7|4,6|3,7|5,5": {r:6, c:5}, "7,7|7,9|6,10": {r:5, c:9},Â  Â  Â 
Â  Â  Â  Â  Â  Â  "7,7|7,9|6,10|5,9": {r:5, c:8}, "7,7|9,7|10,6": {r:11, c:7},Â  Â Â 
Â  Â  Â  Â  Â  Â  "7,7|7,4|6,3": {r:5, c:4}, "7,7|4,7|3,6": {r:2, c:7},Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  "7,7|8,5|9,4": {r:7, c:3}, "7,7|9,9|10,10": {r:8, c:11},Â  Â 
Â  Â  Â  Â  Â  Â  "7,7|5,5|4,4": {r:3, c:5}, "": {r:7, c:7}Â 
Â  Â  Â  Â  };
Â  Â  Â  Â  const INV_OP = [0, 3, 2, 1, 4, 5, 6, 7];
Â  Â  Â  Â  function transform(r, c, op) {
Â  Â  Â  Â  Â  Â  let nr = r - 7, nc = c - 7;
Â  Â  Â  Â  Â  Â  let tr, tc;
Â  Â  Â  Â  Â  Â  switch(op) {
Â  Â  Â  Â  Â  Â  Â  Â  case 0: tr=nr; tc=nc; break; case 1: tr=nc; tc=-nr; break;
Â  Â  Â  Â  Â  Â  Â  Â  case 2: tr=-nr; tc=-nc; break; case 3: tr=-nc; tc=nr; break;
Â  Â  Â  Â  Â  Â  Â  Â  case 4: tr=nr; tc=-nc; break; case 5: tr=-nr; tc=nc; break;
Â  Â  Â  Â  Â  Â  Â  Â  case 6: tr=nc; tc=nr; break; case 7: tr=-nc; tc=-nr; break;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  return {r: tr+7, c: tc+7};
Â  Â  Â  Â  }
Â  Â  Â  Â  function matchBook(history) {
Â  Â  Â  Â  Â  Â  if (history.length === 0) return BOOK[""];
Â  Â  Â  Â  Â  Â  for(let op=0; op<8; op++) {
Â  Â  Â  Â  Â  Â  Â  Â  let keyParts = []; let valid = true;
Â  Â  Â  Â  Â  Â  Â  Â  for(let m of history) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let t = transform(m.r, m.c, op);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (t.r < 0 || t.r > 14 || t.c < 0 || t.c > 14) { valid = false; break; }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  keyParts.push(t.r + "," + t.c);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (!valid) continue;
Â  Â  Â  Â  Â  Â  Â  Â  let key = keyParts.join("|");
Â  Â  Â  Â  Â  Â  Â  Â  if (BOOK[key]) { let best = BOOK[key]; let invOp = INV_OP[op]; return transform(best.r, best.c, invOp); }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  return null;
Â  Â  Â  Â  }

Â  Â  Â  Â  const POS_WEIGHTS = new Int32Array(225);
Â  Â  Â  Â  for(let r=0; r<15; r++) for(let c=0; c<15; c++) {
Â  Â  Â  Â  Â  Â  let d = Math.sqrt((r-7)*(r-7) + (c-7)*(c-7));
Â  Â  Â  Â  Â  Â  POS_WEIGHTS[r*15+c] = Math.round(100 * Math.exp(-d/5)) * 10;Â 
Â  Â  Â  Â  }
Â  Â  Â  Â  const ZOBRIST = [new BigUint64Array(225), new BigUint64Array(225)];
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  let seed = 0xDEADBEEFn;
Â  Â  Â  Â  Â  Â  function rand() { seed = (seed * 6364136223846793005n + 1442695040888963407n); return seed; }
Â  Â  Â  Â  Â  Â  for(let p=0; p<2; p++) for(let i=0; i<225; i++) ZOBRIST[p][i] = rand();
Â  Â  Â  Â  }
Â  Â  Â  Â  let TT = new Map();
Â  Â  Â  Â  let KILLER = Array.from({length: 60}, () => [null, null]);
Â  Â  Â  Â  let HISTORY = [new Int32Array(225), new Int32Array(225)];
Â  Â  Â  Â  let MCTS_SCORES = new Int32Array(225);Â 
Â  Â  Â  Â  const DIRECTIONS = [1n, 15n, 16n, 14n];Â 
Â  Â  Â  Â Â 
Â  Â  Â  Â  self.onmessage = function(e) {
Â  Â  Â  Â  Â  Â  const d = e.data;Â 
Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  if (d.type === 'RESET') {Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  TT.clear(); KILLER = Array.from({length: 60}, () => [null, null]);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  HISTORY = [new Int32Array(225), new Int32Array(225)];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  MCTS_SCORES.fill(0); return;Â 
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  const b = BigInt(d.b); const w = BigInt(d.w); const turn = d.turn;
Â  Â  Â  Â  Â  Â  Â  Â  let currentHash = computeHash(b, w);
Â  Â  Â  Â  Â  Â  Â  Â  // [FIXED] evalFull now uses strict boundary checks
Â  Â  Â  Â  Â  Â  Â  Â  let initScoreB = evalFull(b, w) + evalPositionalTotal(b);
Â  Â  Â  Â  Â  Â  Â  Â  let initScoreW = evalFull(w, b) + evalPositionalTotal(w);

Â  Â  Â  Â  Â  Â  Â  Â  if (d.type === 'HINT') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  startTime = Date.now();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let hist = parseHistory(d.history);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let bookMove = matchBook(hist);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (bookMove) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let p = BigInt(bookMove.r * 15 + bookMove.c);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!(turn === 1 && isForbidden(b | (1n << p), w, p))) { self.postMessage({ type: 'HINT_RESULT', move: bookMove }); return; }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const res = runPVS(b, w, turn, currentHash, 800, initScoreB, initScoreW);Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let finalMove = res.move;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (turn === 1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â let p = BigInt(finalMove.r * 15 + finalMove.c);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (isForbidden(b | (1n << p), w, p)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â let fallback = getRankedCands(b, w, turn, 0, null, true);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â let foundSafe = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â for (let fm of fallback) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â let fp = BigInt(fm.r * 15 + fm.c);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (!isForbidden(b | (1n << fp), w, fp)) { finalMove = fm; foundSafe = true; break; }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (!foundSafe) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â for(let i=0; i<225; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if ((b|w) & (1n << BigInt(i))) continue;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â let r = Math.floor(i/15), c = i%15;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (!hasNeighbor(b|w, r, c)) continue;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â let fp = BigInt(i);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (!isForbidden(b | (1n << fp), w, fp)) { finalMove = {r: r, c: c}; break; }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  self.postMessage({ type: 'HINT_RESULT', move: finalMove });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (d.type === 'THINK') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  nodes = 0; cutoffs = 0; mctsSims = 0; startTime = Date.now(); MCTS_SCORES.fill(0);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let hist = parseHistory(d.history);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let bookMove = matchBook(hist);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (bookMove) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â let idx = BigInt(bookMove.r * 15 + bookMove.c);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (!((b|w) & (1n << idx))) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â self.postMessage({ type: 'RESULT', move: bookMove, nodes: 1, cutoffs: 0, mcts: 0, score: 99999, time: 1, depth: 'BOOK', note: 'GM BOOK' });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â return;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let winSeq = solveVCF(b, w, turn, 0, []);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (winSeq) { self.postMessage({ type: 'RESULT', move: winSeq[0], nodes, cutoffs, mcts: 0, time: Date.now()-startTime, depth: 'VCF', note: 'VCF WIN' }); return; }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let vctSeq = solveVCT(b, w, turn, 0, []);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (vctSeq) { self.postMessage({ type: 'RESULT', move: vctSeq[0], nodes, cutoffs, mcts: 0, time: Date.now()-startTime, depth: 'VCT', note: 'VCT FOUND' }); return; }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const stoneCount = countStones(b|w);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let mctsTime = (stoneCount < 180) ? (stoneCount < 10 ? TIME_LIMIT * 0.4 : TIME_LIMIT * 0.1) : 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (mctsTime > 0) runMCTS(b, w, turn, mctsTime);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const result = runPVS(b, w, turn, currentHash, TIME_LIMIT, initScoreB, initScoreW);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!result || !result.move) throw "No move found";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  self.postMessage({ type: 'RESULT', move: result.move, nodes, cutoffs, mcts: mctsSims, score: result.val, time: Date.now() - startTime, depth: result.depth, note: 'GM ENGINE' });
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  } catch (err) {
Â  Â  Â  Â  Â  Â  Â  Â  const fb_b = BigInt(e.data.b); const fb_w = BigInt(e.data.w);
Â  Â  Â  Â  Â  Â  Â  Â  let fallbackMoves = getRankedCands(fb_b, fb_w, e.data.turn, 0, null, true);
Â  Â  Â  Â  Â  Â  Â  Â  let safeMove = {r:7, c:7};
Â  Â  Â  Â  Â  Â  Â  Â  for (let m of fallbackMoves) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let p = BigInt(m.r * 15 + m.c);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (e.data.turn === 1 && isForbidden(fb_b | (1n << p), fb_w, p)) continue;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  safeMove = m; break;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (d.type === 'HINT') { self.postMessage({ type: 'HINT_RESULT', move: safeMove }); }Â 
Â  Â  Â  Â  Â  Â  Â  Â  else { self.postMessage({ type: 'RESULT', move: safeMove, nodes: nodes, cutoffs: 0, mcts: 0, score: 0, time: 0, depth: 'ERR', note: 'RECOVERY' }); }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  };

Â  Â  Â  Â  function parseHistory(str) {
Â  Â  Â  Â  Â  Â  if (!str) return [];
Â  Â  Â  Â  Â  Â  try { return str.split('|').map(s => { let p = s.split(','); return {r: parseInt(p[0]), c: parseInt(p[1])}; }); }
Â  Â  Â  Â  Â  Â  catch(e) { return []; }
Â  Â  Â  Â  }
Â  Â  Â  Â  function countStones(occ) { let c=0; for(let i=0; i<225; i++) if((occ>>BigInt(i))&1n) c++; return c; }
Â  Â  Â  Â  function computeHash(b, w) {
Â  Â  Â  Â  Â  Â  let h = 0n; for(let i=0; i<225; i++) { if((b>>BigInt(i))&1n) h^=ZOBRIST[0][i]; if((w>>BigInt(i))&1n) h^=ZOBRIST[1][i]; } return h;
Â  Â  Â  Â  }

Â  Â  Â  Â  class MCTSNode { constructor(p,m,t){this.parent=p;this.move=m;this.turn=t;this.wins=0;this.visits=0;this.children=[];this.untried=[];this.isTerminal=false;}}
Â  Â  Â  Â  function runMCTS(b,w,rt,tb){
Â  Â  Â  Â  Â  Â  let root=new MCTSNode(null,null,rt);
Â  Â  Â  Â  Â  Â  let cands=getRankedCands(b,w,rt,0,null,true).slice(0,30);
Â  Â  Â  Â  Â  Â  for(let c of cands)root.untried.push(c);
Â  Â  Â  Â  Â  Â  let et=Date.now()+tb;
Â  Â  Â  Â  Â  Â  while(Date.now()<et){
Â  Â  Â  Â  Â  Â  Â  Â  mctsSims++; let n=root; let cb=b,cw=w; let ct=rt;
Â  Â  Â  Â  Â  Â  Â  Â  while(n.untried.length===0&&n.children.length>0){
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  n=uctSelect(n); let p=BigInt(n.move.r*15+n.move.c);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(n.parent.turn===1)cb|=(1n<<p);else cw|=(1n<<p); ct=3-n.parent.turn;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if(n.untried.length>0){
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let m=n.untried.pop(); let p=BigInt(m.r*15+m.c);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(n.turn===1&&isForbidden(cb|(1n<<p),cw,p)){
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  n.isTerminal=true; let c=new MCTSNode(n,m,3-n.turn); c.isTerminal=true; c.visits=1; c.wins=(n.turn===1)?-1000:1000; n.children.push(c); n=c;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }else{
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let c=new MCTSNode(n,m,3-n.turn); n.children.push(c); n=c;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(n.parent.turn===1)cb|=(1n<<p);else cw|=(1n<<p); ct=3-n.parent.turn;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(!checkWin(ct===2?cb:cw,p)){
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let nc=getRankedCands(cb,cw,ct,0,null,true).slice(0,10); for(let cc of nc)n.untried.push(cc);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }else n.isTerminal=true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  let res=0;
Â  Â  Â  Â  Â  Â  Â  Â  if(!n.isTerminal) res=runPatternSimulation(cb,cw,ct);
Â  Â  Â  Â  Â  Â  Â  Â  else { if(n.wins<-500)res=2; else if(n.wins>500)res=1; else res=3-n.turn; }
Â  Â  Â  Â  Â  Â  Â  Â  while(n){ n.visits++; if(res===(3-n.turn))n.wins++; else if(res===n.turn)n.wins--; n=n.parent; }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  for(let c of root.children){ MCTS_SCORES[c.move.r*15+c.move.c] = (c.wins/c.visits)*3000+(c.visits*20); }
Â  Â  Â  Â  }
Â  Â  Â  Â  function uctSelect(n){ let b=null,bs=-1e9; for(let c of n.children){ let s=(c.wins/c.visits)+1.41*Math.sqrt(Math.log(n.visits)/c.visits); if(s>bs){bs=s;b=c;}} return b; }
Â  Â  Â  Â  function runPatternSimulation(b,w,t){
Â  Â  Â  Â  Â  Â  Â let cb=b,cw=w,ct=t,s=0;
Â  Â  Â  Â  Â  Â  Â while(s<40){
Â  Â  Â  Â  Â  Â  Â  Â  Â let wm=findWinMove(cb,cw,ct); if(wm)return ct;
Â  Â  Â  Â  Â  Â  Â  Â  Â let ms=getRankedCands(cb,cw,ct,70,null,true).slice(0,5); if(ms.length===0)return 3;
Â  Â  Â  Â  Â  Â  Â  Â  Â let bm=ms[0]; if(Math.random()>0.6&&ms.length>1)bm=ms[1];
Â  Â  Â  Â  Â  Â  Â  Â  Â let p=BigInt(bm.r*15+bm.c);
Â  Â  Â  Â  Â  Â  Â  Â  Â if(ct===1&&isForbidden(cb|(1n<<p),cw,p))return 2;
Â  Â  Â  Â  Â  Â  Â  Â  Â if(ct===1)cb|=(1n<<p);else cw|=(1n<<p);
Â  Â  Â  Â  Â  Â  Â  Â  Â if(s>30&&hasNeighbor(cb|cw,bm.r,bm.c))s--; ct=3-ct; s++;
Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â let sb=evalFull(cb,cw)+evalPositionalTotal(cb), sw=evalFull(cw,cb)+evalPositionalTotal(cw);
Â  Â  Â  Â  Â  Â  Â if(sb>sw*1.05)return 1; if(sw>sb*1.05)return 2; return 3;
Â  Â  Â  Â  }

Â  Â  Â  Â  function storeKiller(depth, move) {
Â  Â  Â  Â  Â  Â  if (KILLER[depth][0] && KILLER[depth][0].r === move.r && KILLER[depth][0].c === move.c) return;
Â  Â  Â  Â  Â  Â  KILLER[depth][1] = KILLER[depth][0];
Â  Â  Â  Â  Â  Â  KILLER[depth][0] = move;
Â  Â  Â  Â  }

Â  Â  Â  Â  function runPVS(b, w, turn, hash, limit, scoreB, scoreW) {
Â  Â  Â  Â  Â  Â  let cands = getRankedCands(b, w, turn, 0, null, false);
Â  Â  Â  Â  Â  Â  let bestMove = {r:7, c:7};
Â  Â  Â  Â  Â  Â  for (let m of cands) {
Â  Â  Â  Â  Â  Â  Â  Â  Â let p = BigInt(m.r * 15 + m.c);
Â  Â  Â  Â  Â  Â  Â  Â  Â if (turn === 1 && isForbidden(b | (1n << p), w, p)) continue;
Â  Â  Â  Â  Â  Â  Â  Â  Â bestMove = m; break;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  let maxD = 0; let previousScore = 0; let window = 25000;Â 
Â  Â  Â  Â  Â  Â  for (let d = 2; d <= 22; d++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â maxD = d; let alpha = -INF; let beta = INF;
Â  Â  Â  Â  Â  Â  Â  Â  Â if (d >= 4) { alpha = previousScore - window; beta = previousScore + window; }
Â  Â  Â  Â  Â  Â  Â  Â  Â let score = pvsRoot(b, w, turn, d, alpha, beta, hash, limit, scoreB, scoreW);
Â  Â  Â  Â  Â  Â  Â  Â  Â if (score.val <= alpha || score.val >= beta) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â window = 5000000;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (Date.now() - startTime < limit) score = pvsRoot(b, w, turn, d, -INF, INF, hash, limit, scoreB, scoreW);
Â  Â  Â  Â  Â  Â  Â  Â  Â } else { window = Math.max(10000, window - 5000); }
Â  Â  Â  Â  Â  Â  Â  Â  Â if (Date.now() - startTime > limit) break;
Â  Â  Â  Â  Â  Â  Â  Â  Â previousScore = score.val; if (score.move) bestMove = score.move;
Â  Â  Â  Â  Â  Â  Â  Â  Â for(let p=0; p<2; p++) for(let i=0; i<225; i++) HISTORY[p][i] = (HISTORY[p][i] * 0.9) >> 0;Â 
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  return { move: bestMove, depth: maxD, val: previousScore };
Â  Â  Â  Â  }

Â  Â  Â  Â  function pvsRoot(b, w, turn, depth, alpha, beta, hash, limit, scB, scW) {
Â  Â  Â  Â  Â  Â  Â let rootMoves = getRankedCands(b, w, turn, depth, null, true);Â 
Â  Â  Â  Â  Â  Â  Â if (rootMoves.length === 0) return {val: 0, move: {r:7, c:7}};
Â  Â  Â  Â  Â  Â  Â let bestScore = -INF; let bestMove = null;
Â  Â  Â  Â  Â  Â  Â for (let i = 0; i < rootMoves.length; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  if (Date.now() - startTime > limit) break;
Â  Â  Â  Â  Â  Â  Â  Â  let m = rootMoves[i]; let pos = BigInt(m.r * 15 + m.c);
Â  Â  Â  Â  Â  Â  Â  Â  if (turn === 1 && isForbidden(b | (1n << pos), w, pos)) continue;
Â  Â  Â  Â  Â  Â  Â  Â  if (!bestMove) bestMove = m;
Â  Â  Â  Â  Â  Â  Â  Â  let nextHash = hash ^ ZOBRIST[turn-1][m.r*15 + m.c];
Â  Â  Â  Â  Â  Â  Â  Â  let nb = turn === 1 ? b | (1n << pos) : b; let nw = turn === 2 ? w | (1n << pos) : w;
Â  Â  Â  Â  Â  Â  Â  Â  let deltaB = evalLines(nb, nw, m.r, m.c) - evalLines(b, w, m.r, m.c);
Â  Â  Â  Â  Â  Â  Â  Â  let deltaW = evalLines(nw, nb, m.r, m.c) - evalLines(w, b, m.r, m.c);
Â  Â  Â  Â  Â  Â  Â  Â  if (turn === 1) deltaB += POS_WEIGHTS[m.r*15+m.c]; else deltaW += POS_WEIGHTS[m.r*15+m.c];
Â  Â  Â  Â  Â  Â  Â  Â  let nextScB = scB + deltaB; let nextScW = scW + deltaW;
Â  Â  Â  Â  Â  Â  Â  Â  let score;
Â  Â  Â  Â  Â  Â  Â  Â  if (i === 0) score = -pvs(nb, nw, 3 - turn, depth - 1, -beta, -alpha, nextHash, nextScB, nextScW);
Â  Â  Â  Â  Â  Â  Â  Â  else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  score = -pvs(nb, nw, 3 - turn, depth - 1, -alpha - 1, -alpha, nextHash, nextScB, nextScW);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (score > alpha && score < beta) score = -pvs(nb, nw, 3 - turn, depth - 1, -beta, -alpha, nextHash, nextScB, nextScW);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (score > bestScore) { bestScore = score; bestMove = m; }
Â  Â  Â  Â  Â  Â  Â  Â  alpha = Math.max(alpha, score); if (alpha >= beta) break;Â 
Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â if (!bestMove) bestMove = {r:7, c:7};
Â  Â  Â  Â  Â  Â  Â return { val: bestScore, move: bestMove };
Â  Â  Â  Â  }

Â  Â  Â  Â  function pvs(b, w, turn, depth, alpha, beta, hash, scB, scW) {
Â  Â  Â  Â  Â  Â  nodes++;
Â  Â  Â  Â  Â  Â  let ttEntry = TT.get(hash);
Â  Â  Â  Â  Â  Â  if (ttEntry && ttEntry.depth >= depth) {
Â  Â  Â  Â  Â  Â  Â  Â  if (ttEntry.flag === 0) return ttEntry.score;
Â  Â  Â  Â  Â  Â  Â  Â  if (ttEntry.flag === 1) alpha = Math.max(alpha, ttEntry.score);
Â  Â  Â  Â  Â  Â  Â  Â  else if (ttEntry.flag === 2) beta = Math.min(beta, ttEntry.score);
Â  Â  Â  Â  Â  Â  Â  Â  if (alpha >= beta) { cutoffs++; return ttEntry.score; }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  if (depth === 0) return quiescence(b, w, turn, alpha, beta, 6, scB, scW);
Â  Â  Â  Â  Â  Â  if (depth >= 3 && Math.abs(beta) < 50000000) {
Â  Â  Â  Â  Â  Â  Â  Â  Â let nullScore = -pvs(b, w, 3-turn, depth - 3, -beta, -beta + 1, hash, scB, scW);
Â  Â  Â  Â  Â  Â  Â  Â  Â if (nullScore >= beta) return beta;Â 
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  if (turn === 1 && scW > 40000000) return -100000000 + depth;Â 
Â  Â  Â  Â  Â  Â  if (turn === 2 && scB > 40000000) return -100000000 + depth;Â 
Â  Â  Â  Â  Â  Â  let cands = getRankedCands(b, w, turn, depth, ttEntry ? ttEntry.move : null, false);
Â  Â  Â  Â  Â  Â  if (cands.length === 0) return (turn === 1) ? (scB - scW + 50) : -(scB - scW + 50);
Â  Â  Â  Â  Â  Â  let val = -INF; let bestM = null; let originalAlpha = alpha;
Â  Â  Â  Â  Â  Â  for (let i = 0; i < cands.length; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  let m = cands[i];
Â  Â  Â  Â  Â  Â  Â  Â  let pos = BigInt(m.r * 15 + m.c);
Â  Â  Â  Â  Â  Â  Â  Â  if (turn === 1 && isForbidden(b | (1n << pos), w, pos)) continue;
Â  Â  Â  Â  Â  Â  Â  Â  let nb = turn === 1 ? b | (1n << pos) : b; let nw = turn === 2 ? w | (1n << pos) : w;
Â  Â  Â  Â  Â  Â  Â  Â  let nextHash = hash ^ ZOBRIST[turn-1][m.r*15 + m.c];
Â  Â  Â  Â  Â  Â  Â  Â  let deltaB = evalLines(nb, nw, m.r, m.c) - evalLines(b, w, m.r, m.c);
Â  Â  Â  Â  Â  Â  Â  Â  let deltaW = evalLines(nw, nb, m.r, m.c) - evalLines(w, b, m.r, m.c);
Â  Â  Â  Â  Â  Â  Â  Â  if (turn === 1) deltaB += POS_WEIGHTS[m.r*15+m.c]; else deltaW += POS_WEIGHTS[m.r*15+m.c];
Â  Â  Â  Â  Â  Â  Â  Â  let nextScB = scB + deltaB; let nextScW = scW + deltaW;
Â  Â  Â  Â  Â  Â  Â  Â  let nextDepth = depth - 1;
Â  Â  Â  Â  Â  Â  Â  Â  if (depth >= 3 && i >= 4 && !checkWin(turn===1?nb:nw, pos)) { nextDepth--; }
Â  Â  Â  Â  Â  Â  Â  Â  let score = -pvs(nb, nw, 3 - turn, nextDepth, -beta, -alpha, nextHash, nextScB, nextScW);
Â  Â  Â  Â  Â  Â  Â  Â  if (nextDepth < depth - 1 && score > alpha) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  score = -pvs(nb, nw, 3 - turn, depth - 1, -beta, -alpha, nextHash, nextScB, nextScW);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (score > val) { val = score; bestM = m; }
Â  Â  Â  Â  Â  Â  Â  Â  alpha = Math.max(alpha, val);
Â  Â  Â  Â  Â  Â  Â  Â  if (alpha >= beta) { cutoffs++; storeKiller(depth, m); HISTORY[turn-1][m.r*15 + m.c] += depth * depth; break; }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  let flag = 0; if (val <= originalAlpha) flag = 2; else if (val >= beta) flag = 1;Â 
Â  Â  Â  Â  Â  Â  storeTT(hash, depth, val, flag, bestM);
Â  Â  Â  Â  Â  Â  return val;
Â  Â  Â  Â  }
Â  Â  Â  Â  function storeTT(hash, depth, score, flag, move) {
Â  Â  Â  Â  Â  Â  let entry = TT.get(hash); if (entry && entry.depth > depth) return;Â 
Â  Â  Â  Â  Â  Â  if (TT.size > MAX_TT_SIZE && !entry) { const oldest = TT.keys().next().value; TT.delete(oldest); }
Â  Â  Â  Â  Â  Â  TT.set(hash, { depth, score, flag, move });
Â  Â  Â  Â  }
Â  Â  Â  Â  function quiescence(b, w, turn, alpha, beta, qsDepth, scB, scW) {
Â  Â  Â  Â  Â  Â  nodes++;
Â  Â  Â  Â  Â  Â  let totalScore = scB - scW; if (turn === 1) totalScore += 500; else totalScore -= 500;
Â  Â  Â  Â  Â  Â  let standPat = (turn === 1) ? totalScore : -totalScore;
Â  Â  Â  Â  Â  Â  if (standPat >= beta) return beta; if (standPat > alpha) alpha = standPat;
Â  Â  Â  Â  Â  Â  if (qsDepth <= 0) return standPat;
Â  Â  Â  Â  Â  Â  let cands = getRankedCands(b, w, turn, 30, null, false);
Â  Â  Â  Â  Â  Â  let noisyMoves = []; let threshold = standPat < -10000 ? 5000 : 20000;
Â  Â  Â  Â  Â  Â  for(let m of cands) { if (m.s >= 50000) noisyMoves.push(m); else if (m.s >= threshold) noisyMoves.push(m); }
Â  Â  Â  Â  Â  Â  for (let m of noisyMoves) {
Â  Â  Â  Â  Â  Â  Â  Â  let pos = BigInt(m.r * 15 + m.c);
Â  Â  Â  Â  Â  Â  Â  Â  if (turn === 1 && isForbidden(b | (1n << pos), w, pos)) continue;
Â  Â  Â  Â  Â  Â  Â  Â  let nb = turn === 1 ? b | (1n << pos) : b; let nw = turn === 2 ? w | (1n << pos) : w;
Â  Â  Â  Â  Â  Â  Â  Â  let deltaB = evalLines(nb, nw, m.r, m.c) - evalLines(b, w, m.r, m.c);
Â  Â  Â  Â  Â  Â  Â  Â  let deltaW = evalLines(nw, nb, m.r, m.c) - evalLines(w, b, m.r, m.c);
Â  Â  Â  Â  Â  Â  Â  Â  if (turn === 1) deltaB += POS_WEIGHTS[m.r*15+m.c]; else deltaW += POS_WEIGHTS[m.r*15+m.c];
Â  Â  Â  Â  Â  Â  Â  Â  let score = -quiescence(nb, nw, 3 - turn, -beta, -alpha, qsDepth - 1, scB + deltaB, scW + deltaW);
Â  Â  Â  Â  Â  Â  Â  Â  if (score > alpha) { alpha = score; if (score >= beta) return beta; }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  return alpha;
Â  Â  Â  Â  }
Â  Â  Â  Â  function evalPositionalTotal(my) { let s = 0; for(let i=0; i<225; i++) if((my >> BigInt(i)) & 1n) s += POS_WEIGHTS[i]; return s; }
Â  Â  Â  Â Â 
Â  Â  Â  Â  // [FIXED] EVALUATION NOW CHECKS BOUNDARIES
Â  Â  Â  Â  function evalLines(my, opp, r, c) {
Â  Â  Â  Â  Â  Â  let score = 0; const occ = my | opp;
Â  Â  Â  Â  Â  Â  score += evalSingleLine(my, occ, r, c, 0, 1, 15); // Horizontal
Â  Â  Â  Â  Â  Â  score += evalSingleLine(my, occ, r, c, 1, 0, 15); // Vertical
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // Diagonals (using smart bounds)
Â  Â  Â  Â  Â  Â  let startD1 = getDiagStart(r, c, 16);Â 
Â  Â  Â  Â  Â  Â  score += evalSingleLine(my, occ, startD1.r, startD1.c, 1, 1, startD1.len);
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  let startD2 = getDiagStart(r, c, 14);Â 
Â  Â  Â  Â  Â  Â  score += evalSingleLine(my, occ, startD2.r, startD2.c, 1, -1, startD2.len);
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  return score;
Â  Â  Â  Â  }
Â  Â  Â  Â  function getDiagStart(r, c, dir) {
Â  Â  Â  Â  Â  Â  Â let cr = r, cc = c;Â 
Â  Â  Â  Â  Â  Â  Â if (dir === 16) { while(cr > 0 && cc > 0) { cr--; cc--; } }Â 
Â  Â  Â  Â  Â  Â  Â else { while(cr > 0 && cc < 14) { cr--; cc++; } }
Â  Â  Â  Â  Â  Â  Â let len = 0; let tr = cr, tc = cc;
Â  Â  Â  Â  Â  Â  Â if (dir === 16) { while(tr < 15 && tc < 15) { len++; tr++; tc++; } }Â 
Â  Â  Â  Â  Â  Â  Â else { while(tr < 15 && tc >= 0) { len++; tr++; tc--; } }
Â  Â  Â  Â  Â  Â  Â return { r: cr, c: cc, len: len };
Â  Â  Â  Â  }
Â  Â  Â  Â  // [FIXED] STRICT BOUNDARY CHECK INSIDE SCORING
Â  Â  Â  Â  function evalSingleLine(my, occ, startR, startC, dr, dc, count) {
Â  Â  Â  Â  Â  Â  let score = 0;Â 
Â  Â  Â  Â  Â  Â  let currR = startR, currC = startC;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  for (let i = 0; i < count; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  let p = BigInt(currR * 15 + currC);
Â  Â  Â  Â  Â  Â  Â  Â  if (!((my >> p) & 1n)) {Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currR += dr; currC += dc;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  continue;Â 
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  let prevR = currR - dr, prevC = currC - dc;
Â  Â  Â  Â  Â  Â  Â  Â  let isStart = true;
Â  Â  Â  Â  Â  Â  Â  Â  if (i > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â let pp = BigInt(prevR * 15 + prevC);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if ((my >> pp) & 1n) isStart = false;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (isStart) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let len = 1;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let nextR = currR + dr, nextC = currC + dc;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let k = i + 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  while (k < count) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let np = BigInt(nextR * 15 + nextC);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!((my >> np) & 1n)) break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  len++; nextR += dr; nextC += dc; k++;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let lOpen = false, rOpen = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (i > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let pp = BigInt(prevR * 15 + prevC);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!((occ >> pp) & 1n)) lOpen = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (k < count) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let np = BigInt(nextR * 15 + nextC);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!((occ >> np) & 1n)) rOpen = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (len >= 5) score += 100000000;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  else if (len === 4) { if (lOpen && rOpen) score += 50000000; else if (lOpen || rOpen) score += 500000; }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  else if (len === 3) { if (lOpen && rOpen) score += 30000; else if (lOpen || rOpen) score += 2000; }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  else if (len === 2) { if (lOpen && rOpen) score += 3000; }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  currR += dr; currC += dc;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  return score;
Â  Â  Â  Â  }

Â  Â  Â  Â  function evalFull(my, opp) {
Â  Â  Â  Â  Â  Â  let score = 0; const occ = my | opp;
Â  Â  Â  Â  Â  Â  for(let r=0; r<15; r++) score += evalSingleLine(my, occ, r, 0, 0, 1, 15);
Â  Â  Â  Â  Â  Â  for(let c=0; c<15; c++) score += evalSingleLine(my, occ, 0, c, 1, 0, 15);
Â  Â  Â  Â  Â  Â  for(let c=0; c<15; c++) { let res = getDiagStart(0, c, 16); if (res.len >= 5) score += evalSingleLine(my, occ, res.r, res.c, 1, 1, res.len); }
Â  Â  Â  Â  Â  Â  for(let r=1; r<15; r++) { let res = getDiagStart(r, 0, 16); if (res.len >= 5) score += evalSingleLine(my, occ, res.r, res.c, 1, 1, res.len); }
Â  Â  Â  Â  Â  Â  for(let c=0; c<15; c++) { let res = getDiagStart(0, c, 14); if (res.len >= 5) score += evalSingleLine(my, occ, res.r, res.c, 1, -1, res.len); }
Â  Â  Â  Â  Â  Â  for(let r=1; r<15; r++) { let res = getDiagStart(r, 14, 14); if (res.len >= 5) score += evalSingleLine(my, occ, res.r, res.c, 1, -1, res.len); }
Â  Â  Â  Â  Â  Â  return score;
Â  Â  Â  Â  }

Â  Â  Â  Â  function solveVCT(b, w, turn, depth, path) {
Â  Â  Â  Â  Â  Â  if (depth > 12 || Date.now() - startTime > 3000) return null;Â 
Â  Â  Â  Â  Â  Â  let cands = getRankedCands(b, w, turn, 0, null, false).slice(0, 15);
Â  Â  Â  Â  Â  Â  let forcingMoves = [];
Â  Â  Â  Â  Â  Â  for(let m of cands) if (m.s >= 25000) forcingMoves.push(m);
Â  Â  Â  Â  Â  Â  for (let atk of forcingMoves) {
Â  Â  Â  Â  Â  Â  Â  Â  let pos = BigInt(atk.r * 15 + atk.c);
Â  Â  Â  Â  Â  Â  Â  Â  if (turn === 1 && isForbidden(b | (1n << pos), w, pos)) continue;
Â  Â  Â  Â  Â  Â  Â  Â  let nextB = (turn === 1 ? (b | (1n << pos)) : b); let nextW = (turn === 2 ? (w | (1n << pos)) : w);
Â  Â  Â  Â  Â  Â  Â  Â  if (checkWin(turn===1?nextB:nextW, pos)) return [...path, atk];
Â  Â  Â  Â  Â  Â  Â  Â  let type = getThreatType(turn===1?nextB:nextW, b|w, pos);
Â  Â  Â  Â  Â  Â  Â  Â  if (type === 0) continue;Â 
Â  Â  Â  Â  Â  Â  Â  Â  let defenses = getDefenses(nextB, nextW, 3-turn, type, pos, turn===1?nextB:nextW);
Â  Â  Â  Â  Â  Â  Â  Â  if (defenses.length === 0) return [...path, atk];
Â  Â  Â  Â  Â  Â  Â  Â  let solvedAll = true; let subPath = null;
Â  Â  Â  Â  Â  Â  Â  Â  for (let def of defenses) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let dPos = BigInt(def.r * 15 + def.c);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let newB = (turn === 2 ? (nextB | (1n << dPos)) : nextB); let newW = (turn === 1 ? (nextW | (1n << dPos)) : nextW);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (checkWin(turn===2?newB:newW, dPos)) { solvedAll = false; break; }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let res = solveVCT(newB, newW, turn, depth + 1, [...path, atk, def]);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!res) { solvedAll = false; break; }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  subPath = res;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (solvedAll) return subPath;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  return null;
Â  Â  Â  Â  }

Â  Â  Â  Â  function solveVCF(b, w, turn, depth, path) {
Â  Â  Â  Â  Â  Â  if (depth > 16 || Date.now() - startTime > 1500) return null;Â 
Â  Â  Â  Â  Â  Â  let attacks = getRankedCands(b, w, turn, 0, null, false).filter(m => m.s >= 400000);Â 
Â  Â  Â  Â  Â  Â  for (let atk of attacks) {
Â  Â  Â  Â  Â  Â  Â  Â  let pos = BigInt(atk.r * 15 + atk.c);
Â  Â  Â  Â  Â  Â  Â  Â  if (turn === 1 && isForbidden(b | (1n << pos), w, pos)) continue;
Â  Â  Â  Â  Â  Â  Â  Â  let nextB = (turn === 1 ? (b | (1n << pos)) : b); let nextW = (turn === 2 ? (w | (1n << pos)) : w);
Â  Â  Â  Â  Â  Â  Â  Â  if (checkWin(turn===1?nextB:nextW, pos)) return [...path, atk];
Â  Â  Â  Â  Â  Â  Â  Â  let defenses = getDefenses(nextB, nextW, 3-turn, 2, pos, turn===1?nextB:nextW);
Â  Â  Â  Â  Â  Â  Â  Â  if (defenses.length === 0) return [...path, atk];Â 
Â  Â  Â  Â  Â  Â  Â  Â  let solvedAll = true; let subPath = null;
Â  Â  Â  Â  Â  Â  Â  Â  for (let def of defenses) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let dPos = BigInt(def.r * 15 + def.c);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let newB = (turn === 2 ? (nextB | (1n << dPos)) : nextB); let newW = (turn === 1 ? (nextW | (1n << dPos)) : nextW);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (checkWin(turn===2?newB:newW, dPos)) { solvedAll = false; break; }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let res = solveVCF(newB, newW, turn, depth + 1, [...path, atk, def]);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!res) { solvedAll = false; break; }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  subPath = res;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (solvedAll) return subPath;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  return null;
Â  Â  Â  Â  }

Â  Â  Â  Â  function getThreatType(my, occ, pos) {
Â  Â  Â  Â  Â  Â  let r = Number(pos / 15n), c = Number(pos % 15n);
Â  Â  Â  Â  Â  Â  for (let dir of DIRECTIONS) {
Â  Â  Â  Â  Â  Â  Â  Â  let count = 1;
Â  Â  Â  Â  Â  Â  Â  Â  let p = pos - dir; let lr = r, lc = c;
Â  Â  Â  Â  Â  Â  Â  Â  while (p >= 0n && (my & (1n << p))) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let nr = Number(p / 15n), nc = Number(p % 15n);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (Math.abs(nr - lr) > 1 || Math.abs(nc - lc) > 1) break;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  count++; p -= dir; lr = nr; lc = nc;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  let lBound = p;Â 
Â  Â  Â  Â  Â  Â  Â  Â  p = pos + dir; let rr = r, rc = c;
Â  Â  Â  Â  Â  Â  Â  Â  while (p < 225n && (my & (1n << p))) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let nr = Number(p / 15n), nc = Number(p % 15n);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (Math.abs(nr - rr) > 1 || Math.abs(nc - rc) > 1) break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  count++; p += dir; rr = nr; rc = nc;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  let rBound = p;
Â  Â  Â  Â  Â  Â  Â  Â  if (count >= 4) return 2;Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (count === 3) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â let lOpen = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (lBound >= 0n && lBound < 225n && !((occ >> lBound) & 1n)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let nr = Number(lBound / 15n), nc = Number(lBound % 15n);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (Math.abs(nr - lr) <= 1 && Math.abs(nc - lc) <= 1) lOpen = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â let rOpen = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (rBound >= 0n && rBound < 225n && !((occ >> rBound) & 1n)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let nr = Number(rBound / 15n), nc = Number(rBound % 15n);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (Math.abs(nr - rr) <= 1 && Math.abs(nc - rc) <= 1) rOpen = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (lOpen && rOpen) return 1;Â 
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  return 0;Â 
Â  Â  Â  Â  }

Â  Â  Â  Â  function getDefenses(b, w, turn, threatType, atkPos, attackerBoard) {Â 
Â  Â  Â  Â  Â  Â  Â let candidates = getRankedCands(b, w, turn, 0, null, false).slice(0, 10);
Â  Â  Â  Â  Â  Â  Â let valid = [];
Â  Â  Â  Â  Â  Â  Â for(let m of candidates) {
Â  Â  Â  Â  Â  Â  Â  Â  Â let dPos = BigInt(m.r * 15 + m.c);
Â  Â  Â  Â  Â  Â  Â  Â  Â if (turn === 1 && isForbidden(b | (1n << dPos), w, dPos)) continue;
Â  Â  Â  Â  Â  Â  Â  Â  Â let myNext = (turn === 1 ? b | (1n << dPos) : w | (1n << dPos));
Â  Â  Â  Â  Â  Â  Â  Â  Â let occ = b | w | (1n << dPos);
Â  Â  Â  Â  Â  Â  Â  Â  Â if (getThreatType(myNext, occ, dPos) >= 2) { valid.push(m); continue; }
Â  Â  Â  Â  Â  Â  Â  Â  Â let newOcc = b | w | (1n << dPos);
Â  Â  Â  Â  Â  Â  Â  Â  Â let stillThreat = getThreatType(attackerBoard, newOcc, atkPos);
Â  Â  Â  Â  Â  Â  Â  Â  Â if (stillThreat < threatType) { valid.push(m); }
Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â return valid.slice(0, 8);
Â  Â  Â  Â  }

Â  Â  Â  Â  function findWinMove(b, w, turn) {
Â  Â  Â  Â  Â  Â  let occ = b | w;
Â  Â  Â  Â  Â  Â  for(let i=0; i<225; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  if (occ & (1n << BigInt(i))) continue;
Â  Â  Â  Â  Â  Â  Â  Â  let pos = BigInt(i); let r = Math.floor(i/15), c = i%15;
Â  Â  Â  Â  Â  Â  Â  Â  if(!hasNeighbor(occ, r, c)) continue;
Â  Â  Â  Â  Â  Â  Â  Â  if (turn === 1) { if (!isForbidden(b|(1n<<pos), w, pos) && checkWin(b|(1n<<pos), pos)) return {r,c}; }Â 
Â  Â  Â  Â  Â  Â  Â  Â  else { if (checkWin(w|(1n<<pos), pos)) return {r,c}; }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  return null;
Â  Â  Â  Â  }
Â  Â  Â  Â  function getRankedCands(b, w, p, depth, ttMove, addNoise) {
Â  Â  Â  Â  Â  Â  let occ = b | w; let my = p === 2 ? w : b; let opp = p === 2 ? b : w;
Â  Â  Â  Â  Â  Â  let list = []; let k1 = null, k2 = null;
Â  Â  Â  Â  Â  Â  if (depth < 60) { k1 = KILLER[depth][0]; k2 = KILLER[depth][1]; }
Â  Â  Â  Â  Â  Â  for(let i=0; i<225; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  if (occ & (1n << BigInt(i))) continue;
Â  Â  Â  Â  Â  Â  Â  Â  let r = Math.floor(i/15), c = i%15;
Â  Â  Â  Â  Â  Â  Â  Â  if (!hasNeighbor(occ, r, c)) continue;
Â  Â  Â  Â  Â  Â  Â  Â  let score = evalMoveUltra(my, opp, b, w, r, c, p);
Â  Â  Â  Â  Â  Â  Â  Â  score += POS_WEIGHTS[i];
Â  Â  Â  Â  Â  Â  Â  Â  if (ttMove && ttMove.r === r && ttMove.c === c) score += 2000000000;
Â  Â  Â  Â  Â  Â  Â  Â  else if (k1 && k1.r === r && k1.c === c) score += 1000000000;
Â  Â  Â  Â  Â  Â  Â  Â  else if (k2 && k2.r === r && k2.c === c) score += 900000000;
Â  Â  Â  Â  Â  Â  Â  Â  score += HISTORY[p-1][i]; score += MCTS_SCORES[i];Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (addNoise) score += Math.floor(Math.random() * 50);
Â  Â  Â  Â  Â  Â  Â  Â  list.push({r, c, s: score});
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  return list.sort((x,y) => y.s - x.s).slice(0, 30);Â 
Â  Â  Â  Â  }
Â  Â  Â  Â  function hasNeighbor(occ, r, c) {
Â  Â  Â  Â  Â  Â  Â for(let dr=-2; dr<=2; dr++) for(let dc=-2; dc<=2; dc++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â if (dr===0 && dc===0) continue;
Â  Â  Â  Â  Â  Â  Â  Â  Â let nr = r+dr, nc = c+dc;
Â  Â  Â  Â  Â  Â  Â  Â  Â if (nr>=0 && nr<15 && nc>=0 && nc<15) if (occ & (1n << BigInt(nr*15+nc))) return true;
Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â return false;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  function evalMoveUltra(my, opp, b, w, r, c, p) {
Â  Â  Â  Â  Â  Â  let score = 0; const occ = b | w;
Â  Â  Â  Â  Â  Â  const knightDirs = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
Â  Â  Â  Â  Â  Â  for(let [dr, dc] of knightDirs) {
Â  Â  Â  Â  Â  Â  Â  Â  let nr = r+dr, nc = c+dc;
Â  Â  Â  Â  Â  Â  Â  Â  if (nr>=0 && nr<15 && nc>=0 && nc<15 && (my & (1n << BigInt(nr*15+nc)))) score += 500;Â 
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  for (let dir of DIRECTIONS) {
Â  Â  Â  Â  Â  Â  Â  Â  let l=0, r_cnt=0;
Â  Â  Â  Â  Â  Â  Â  Â  let lp = BigInt(r*15+c) - dir; let lr = r, lc = c;
Â  Â  Â  Â  Â  Â  Â  Â  while (lp>=0n && (my & (1n<<lp))) {Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let nr = Number(lp / 15n), nc = Number(lp % 15n);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (Math.abs(nr - lr) > 1 || Math.abs(nc - lc) > 1) break;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  l++; lp-=dir; lr=nr; lc=nc;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  let l_open = false;
Â  Â  Â  Â  Â  Â  Â  Â  if (lp >= 0n && lp < 225n && !(occ & (1n << lp))) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â let nr = Number(lp / 15n), nc = Number(lp % 15n);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (Math.abs(nr - lr) <= 1 && Math.abs(nc - lc) <= 1) l_open = true;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  let rp = BigInt(r*15+c) + dir; let rr = r, rc = c;
Â  Â  Â  Â  Â  Â  Â  Â  while (rp<225n && (my & (1n<<rp))) {Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let nr = Number(rp / 15n), nc = Number(rp % 15n);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (Math.abs(nr - rr) > 1 || Math.abs(nc - rc) > 1) break;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r_cnt++; rp+=dir; rr=nr; rc=nc;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  let r_open = false;
Â  Â  Â  Â  Â  Â  Â  Â  if (rp >= 0n && rp < 225n && !(occ & (1n << rp))) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â let nr = Number(rp / 15n), nc = Number(rp % 15n);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (Math.abs(nr - rr) <= 1 && Math.abs(nc - rc) <= 1) r_open = true;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  let len = l + 1 + r_cnt;
Â  Â  Â  Â  Â  Â  Â  Â  if (len >= 5) score += 100000000;
Â  Â  Â  Â  Â  Â  Â  Â  else if (len === 4) { if (l_open || r_open) score += 50000000; if (l_open && r_open) score += 500000; }
Â  Â  Â  Â  Â  Â  Â  Â  else if (len === 3) { if (l_open && r_open) score += 50000; else if (l_open || r_open) score += 1000; }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  let ol=0, or=0;
Â  Â  Â  Â  Â  Â  Â  Â  lp = BigInt(r*15+c) - dir; lr = r; lc = c;
Â  Â  Â  Â  Â  Â  Â  Â  while (lp>=0n && (opp & (1n<<lp))) {Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let nr = Number(lp / 15n), nc = Number(lp % 15n);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (Math.abs(nr - lr) > 1 || Math.abs(nc - lc) > 1) break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ol++; lp-=dir; lr=nr; lc=nc;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  let ol_open = false;
Â  Â  Â  Â  Â  Â  Â  Â  if (lp >= 0n && lp < 225n && !(occ & (1n << lp))) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â let nr = Number(lp / 15n), nc = Number(lp % 15n);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (Math.abs(nr - lr) <= 1 && Math.abs(nc - lc) <= 1) ol_open = true;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  rp = BigInt(r*15+c) + dir; rr = r; rc = c;
Â  Â  Â  Â  Â  Â  Â  Â  while (rp<225n && (opp & (1n<<rp))) {Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let nr = Number(rp / 15n), nc = Number(rp % 15n);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (Math.abs(nr - rr) > 1 || Math.abs(nc - rc) > 1) break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  or++; rp+=dir; rr=nr; rc=nc;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  let or_open = false;
Â  Â  Â  Â  Â  Â  Â  Â  if (rp >= 0n && rp < 225n && !(occ & (1n << rp))) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â let nr = Number(rp / 15n), nc = Number(rp % 15n);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (Math.abs(nr - rr) <= 1 && Math.abs(nc - rc) <= 1) or_open = true;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  let olen = ol + 1 + or;
Â  Â  Â  Â  Â  Â  Â  Â  if (olen >= 5) score += 900000000;Â 
Â  Â  Â  Â  Â  Â  Â  Â  else if (olen === 4) score += 60000000;Â 
Â  Â  Â  Â  Â  Â  Â  Â  else if (olen === 3 && ol_open && or_open) score += 40000;Â 
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  return score;
Â  Â  Â  Â  }

Â  Â  Â  Â  function checkWin(my, pos) {
Â  Â  Â  Â  Â  Â  let r = Number(pos / 15n), c = Number(pos % 15n);
Â  Â  Â  Â  Â  Â  for (let dir of DIRECTIONS) {
Â  Â  Â  Â  Â  Â  Â  Â  let count = 1;
Â  Â  Â  Â  Â  Â  Â  Â  let p = pos - dir; let lr = r, lc = c;
Â  Â  Â  Â  Â  Â  Â  Â  while (p >= 0n && (my & (1n << p))) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let nr = Number(p / 15n), nc = Number(p % 15n);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (Math.abs(nr - lr) > 1 || Math.abs(nc - lc) > 1) break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  count++; p -= dir; lr = nr; lc = nc;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  p = pos + dir; let rr = r, rc = c;
Â  Â  Â  Â  Â  Â  Â  Â  while (p < 225n && (my & (1n << p))) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let nr = Number(p / 15n), nc = Number(p % 15n);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (Math.abs(nr - rr) > 1 || Math.abs(nc - rc) > 1) break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  count++; p += dir; rr = nr; rc = nc;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (count >= 5) return true;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  }

Â  Â  Â  Â  function isForbidden(b, w, pos) {
Â  Â  Â  Â  Â  Â  const occ = b | w; let threes = 0, fours = 0;
Â  Â  Â  Â  Â  Â  let r = Number(pos / 15n), c = Number(pos % 15n);
Â  Â  Â  Â  Â  Â  for (let dir of DIRECTIONS) {
Â  Â  Â  Â  Â  Â  Â  Â  let left = 0, right = 0;
Â  Â  Â  Â  Â  Â  Â  Â  let lp = pos - dir, rp = pos + dir;
Â  Â  Â  Â  Â  Â  Â  Â  let lr = r, lc = c;
Â  Â  Â  Â  Â  Â  Â  Â  while (lp >= 0n && lp < 225n && (b & (1n << lp))) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let nr = Number(lp / 15n), nc = Number(lp % 15n);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (Math.abs(nr - lr) > 1 || Math.abs(nc - lc) > 1) break;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  left++; lp -= dir; lr = nr; lc = nc;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  let rr = r, rc = c;
Â  Â  Â  Â  Â  Â  Â  Â  while (rp >= 0n && rp < 225n && (b & (1n << rp))) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let nr = Number(rp / 15n), nc = Number(rp % 15n);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (Math.abs(nr - rr) > 1 || Math.abs(nc - rc) > 1) break;Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  right++; rp += dir; rr = nr; rc = nc;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  let l_open = false;
Â  Â  Â  Â  Â  Â  Â  Â  if (lp >= 0n && lp < 225n && !(occ & (1n << lp))) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let nr = Number(lp / 15n), nc = Number(lp % 15n);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let pr = (left > 0) ? lr : r; let pc = (left > 0) ? lc : c;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (Math.abs(nr - pr) <= 1 && Math.abs(nc - pc) <= 1) l_open = true;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  let r_open = false;
Â  Â  Â  Â  Â  Â  Â  Â  if (rp >= 0n && rp < 225n && !(occ & (1n << rp))) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let nr = Number(rp / 15n), nc = Number(rp % 15n);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let pr = (right > 0) ? rr : r; let pc = (right > 0) ? rc : c;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (Math.abs(nr - pr) <= 1 && Math.abs(nc - pc) <= 1) r_open = true;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  let len = left + 1 + right;
Â  Â  Â  Â  Â  Â  Â  Â  if (len >= 6) return true;Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (len === 3 && l_open && r_open) threes++;
Â  Â  Â  Â  Â  Â  Â  Â  if (len === 4 && (l_open || r_open)) fours++;Â 
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  return (threes >= 2 || fours >= 2);
Â  Â  Â  Â  }
Â  Â  Â  Â  `;

Â  Â  Â  Â  const canvas = document.getElementById('vBoard');
Â  Â  Â  Â  const ctx = canvas.getContext('2d');
Â  Â  Â  Â  const status = document.getElementById('v_status');
Â  Â  Â  Â  const forbiddenMsg = document.getElementById('v_forbidden');
Â  Â  Â  Â  const nodeStat = document.getElementById('s_nodes');
Â  Â  Â  Â  const modeStat = document.getElementById('s_mode');
Â  Â  Â  Â  const scoreStat = document.getElementById('s_depth');
Â  Â  Â  Â  const uRole = document.getElementById('u_role');
Â  Â  Â  Â  const aRole = document.getElementById('a_role');
Â  Â  Â  Â  const size = 15; const cell = 35; const margin = 45;Â 
Â  Â  Â  Â Â 
Â  Â  Â  Â  let board = Array.from({length: size}, () => Array(size).fill(0));
Â  Â  Â  Â  let isGameOver = false; let moveHistory = []; let mousePos = null; let hintPos = null; let humanColor = 1; let forbiddenMap = [];

Â  Â  Â  Â  const blob = new Blob([workerSource], {type: 'text/javascript'});
Â  Â  Â  Â  const worker = new Worker(window.URL.createObjectURL(blob));

Â  Â  Â  Â  worker.onmessage = function(e) {
Â  Â  Â  Â  Â  Â  const d = e.data;
Â  Â  Â  Â  Â  Â  if (d.type === 'HINT_RESULT') { if (d.move) { hintPos = d.move; drawBoard(); status.innerText = 'ğŸ’¡ HINT RECEIVED'; } return; }
Â  Â  Â  Â  Â  Â  if (d.type === 'RESULT') {
Â  Â  Â  Â  Â  Â  Â  Â  if (d.nodes < 1000) nodeStat.innerText = d.nodes;
Â  Â  Â  Â  Â  Â  Â  Â  else nodeStat.innerText = (d.nodes/1000).toFixed(1) + 'k';
Â  Â  Â  Â  Â  Â  Â  Â  modeStat.innerText = d.note || 'THINK';
Â  Â  Â  Â  Â  Â  Â  Â  scoreStat.innerText = d.depth;
Â  Â  Â  Â  Â  Â  Â  Â  placeStone(d.move.r, d.move.c, 3 - humanColor);Â 
Â  Â  Â  Â  Â  Â  Â  Â  let msg = d.note ? `âš¡ ${d.note}` : `YOUR TURN`;
Â  Â  Â  Â  Â  Â  Â  Â  status.innerText = msg;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  };

Â  Â  Â  Â  function checkForbidden(r, c) {
Â  Â  Â  Â  Â  Â  let boardCopy = board.map(row => [...row]); boardCopy[r][c] = 1;Â 
Â  Â  Â  Â  Â  Â  const dirs = [[0,1],[1,0],[1,1],[1,-1]];
Â  Â  Â  Â  Â  Â  let threes = 0, fours = 0, overline = false;
Â  Â  Â  Â  Â  Â  for (let [dx, dy] of dirs) {
Â  Â  Â  Â  Â  Â  Â  Â  let left = 0, right = 0;
Â  Â  Â  Â  Â  Â  Â  Â  let lx = r - dx, ly = c - dy; while (lx >= 0 && lx < 15 && ly >= 0 && ly < 15 && boardCopy[lx][ly] === 1) { left++; lx -= dx; ly -= dy; }
Â  Â  Â  Â  Â  Â  Â  Â  let l_open = (lx >= 0 && lx < 15 && ly >= 0 && ly < 15 && boardCopy[lx][ly] === 0);
Â  Â  Â  Â  Â  Â  Â  Â  let rx = r + dx, ry = c + dy; while (rx >= 0 && rx < 15 && ry >= 0 && ry < 15 && boardCopy[rx][ry] === 1) { right++; rx += dx; ry += dy; }
Â  Â  Â  Â  Â  Â  Â  Â  let r_open = (rx >= 0 && rx < 15 && ry >= 0 && ry < 15 && boardCopy[rx][ry] === 0);
Â  Â  Â  Â  Â  Â  Â  Â  let len = left + 1 + right;
Â  Â  Â  Â  Â  Â  Â  Â  if (len >= 6) overline = true;
Â  Â  Â  Â  Â  Â  Â  Â  if (len === 3 && l_open && r_open) threes++; if (len === 4 && (l_open || r_open)) fours++;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  if (overline) return "6+"; if (threes >= 2) return "3-3"; if (fours >= 2) return "4-4"; return null;
Â  Â  Â  Â  }

Â  Â  Â  Â  function updateForbiddenMap() { forbiddenMap = []; if (humanColor !== 1) return; for(let r=0; r<size; r++) for(let c=0; c<size; c++) if (board[r][c] === 0 && checkForbidden(r, c)) forbiddenMap.push({r,c}); }
Â  Â  Â  Â  function checkWinLocal(p) {
Â  Â  Â  Â  Â  Â  Â const dirs = [[0,1],[1,0],[1,1],[1,-1]];
Â  Â  Â  Â  Â  Â  Â for (let i = 0; i < size; i++) for (let j = 0; j < size; j++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â if (board[i][j] !== p) continue;
Â  Â  Â  Â  Â  Â  Â  Â  Â for (let [dx, dy] of dirs) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â let count = 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â let x = i + dx, y = j + dy; while (x >= 0 && x < size && y >= 0 && y < size && board[x][y] === p) { count++; x += dx; y += dy; }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â x = i - dx; y = j - dy; while (x >= 0 && x < size && y >= 0 && y < size && board[x][y] === p) { count++; x -= dx; y -= dy; }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â if (count >= 5) return true;
Â  Â  Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â return false;
Â  Â  Â  Â  }

Â  Â  Â  Â  function placeStone(r, c, p) {
Â  Â  Â  Â  Â  Â  if (board[r][c] !== 0) return;
Â  Â  Â  Â  Â  Â  if (p === 1 && moveHistory.length === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  if (r !== 7 || c !== 7) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  forbiddenMsg.innerText = 'âš ï¸ ê·œì¹™: ì²« ìˆ˜ëŠ” ì¤‘ì•™(ì²œì›) í•„ìˆ˜ì…ë‹ˆë‹¤.';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  shakeBoard();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  if (p === 1) { let err = checkForbidden(r, c); if (err) { forbiddenMsg.innerText = `âŒ Forbidden: ${err}`; shakeBoard(); return; } }
Â  Â  Â  Â  Â  Â  board[r][c] = p; moveHistory.push({r, c, p}); hintPos = null; updateForbiddenMap(); drawBoard();
Â  Â  Â  Â  Â  Â  if (checkWinLocal(p)) {
Â  Â  Â  Â  Â  Â  Â  Â  status.innerText = (p === humanColor ? 'ğŸ† YOU WIN!' : 'ğŸ’€ HYPER-VOID WINS!');
Â  Â  Â  Â  Â  Â  Â  Â  status.style.color = p === humanColor ? '#00ffcc' : '#ff4444'; isGameOver = true; return;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  if (p === humanColor) {
Â  Â  Â  Â  Â  Â  Â  Â  status.innerText = 'ğŸ›¡ï¸ AI THINKING...'; status.style.color = '#ccc'; forbiddenMsg.innerText = '';
Â  Â  Â  Â  Â  Â  Â  Â  let b = 0n, w = 0n;
Â  Â  Â  Â  Â  Â  Â  Â  for(let rr=0; rr<size; rr++) for(let cc=0; cc<size; cc++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(board[rr][cc]===1) b |= (1n << BigInt(rr*15 + cc));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if(board[rr][cc]===2) w |= (1n << BigInt(rr*15 + cc));
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  let hStr = moveHistory.map(m => `${m.r},${m.c}`).join("|");
Â  Â  Â  Â  Â  Â  Â  Â  worker.postMessage({ type: 'THINK', b: b.toString(), w: w.toString(), turn: 3 - humanColor, history: hStr });
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  window.requestHint = () => {
Â  Â  Â  Â  Â  Â  Â if(isGameOver || status.innerText.includes('AI')) return;
Â  Â  Â  Â  Â  Â  Â status.innerText = 'ğŸ¤– CHECKING BOOK & HINT...';
Â  Â  Â  Â  Â  Â  Â let b = 0n, w = 0n;
Â  Â  Â  Â  Â  Â  Â for(let rr=0; rr<size; rr++) for(let cc=0; cc<size; cc++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â if(board[rr][cc]===1) b |= (1n << BigInt(rr*15 + cc));
Â  Â  Â  Â  Â  Â  Â  Â  Â if(board[rr][cc]===2) w |= (1n << BigInt(rr*15 + cc));
Â  Â  Â  Â  Â  Â  Â }
Â  Â  Â  Â  Â  Â  Â let hStr = moveHistory.map(m => `${m.r},${m.c}`).join("|");
Â  Â  Â  Â  Â  Â  Â worker.postMessage({ type: 'HINT', b: b.toString(), w: w.toString(), turn: humanColor, history: hStr });
Â  Â  Â  Â  }
Â  Â  Â  Â  function drawBoard() {
Â  Â  Â  Â  Â  Â  ctx.fillStyle = '#051a05'; ctx.fillRect(0, 0, canvas.width, canvas.height);Â 
Â  Â  Â  Â  Â  Â  ctx.fillStyle = '#44cc44'; ctx.font = 'bold 12px "Fira Code", monospace';
Â  Â  Â  Â  Â  Â  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
Â  Â  Â  Â  Â  Â  const cols = "ABCDEFGHIJKLMNO";
Â  Â  Â  Â  Â  Â  for (let i=0; i<size; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  let pos = margin + i * cell;
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillText(cols[i], pos, margin - 25); ctx.fillText(cols[i], pos, margin + (size-1)*cell + 25);
Â  Â  Â  Â  Â  Â  Â  Â  let num = 15 - i; ctx.fillText(num, margin - 25, pos); ctx.fillText(num, margin + (size-1)*cell + 25, pos);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  ctx.lineWidth = 1; ctx.strokeStyle = '#004400'; ctx.beginPath();
Â  Â  Â  Â  Â  Â  for(let i=0; i<size; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  let p = margin + i * cell;
Â  Â  Â  Â  Â  Â  Â  Â  ctx.moveTo(p, margin); ctx.lineTo(p, margin + (size-1)*cell);
Â  Â  Â  Â  Â  Â  Â  Â  ctx.moveTo(margin, p); ctx.lineTo(margin + (size-1)*cell, p);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  ctx.stroke();
Â  Â  Â  Â  Â  Â  ctx.fillStyle = '#006600';
Â  Â  Â  Â  Â  Â  [3, 7, 11].forEach(r => [3, 7, 11].forEach(c => { ctx.beginPath(); ctx.arc(margin + c*cell, margin + r*cell, 4, 0, Math.PI*2); ctx.fill(); }));

Â  Â  Â  Â  Â  Â  if (humanColor === 1 && !isGameOver) {
Â  Â  Â  Â  Â  Â  Â  Â  ctx.strokeStyle = '#844'; ctx.lineWidth = 2;
Â  Â  Â  Â  Â  Â  Â  Â  for (let f of forbiddenMap) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let fx = margin + f.c * cell; let fy = margin + f.r * cell;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath(); ctx.moveTo(fx - 5, fy - 5); ctx.lineTo(fx + 5, fy + 5);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.moveTo(fx + 5, fy - 5); ctx.lineTo(fx - 5, fy + 5); ctx.stroke();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  for(let r=0; r<size; r++) for(let c=0; c<size; c++) if (board[r][c] !== 0) drawStone(r, c, board[r][c]);
Â  Â  Â  Â  Â  Â  if (hintPos && !isGameOver) {
Â  Â  Â  Â  Â  Â  Â  Â  let cx = margin + hintPos.c * cell; let cy = margin + hintPos.r * cell;
Â  Â  Â  Â  Â  Â  Â  Â  ctx.strokeStyle = '#d900ff'; ctx.lineWidth = 3; ctx.setLineDash([5,5]);
Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath(); ctx.arc(cx, cy, 22, 0, Math.PI*2); ctx.stroke(); ctx.setLineDash([]);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  if (mousePos && board[mousePos.r][mousePos.c] === 0 && !isGameOver && !status.innerText.includes('AI')) {
Â  Â  Â  Â  Â  Â  Â  Â  ctx.globalAlpha = 0.5; drawStone(mousePos.r, mousePos.c, humanColor); ctx.globalAlpha = 1.0;
Â  Â  Â  Â  Â  Â  Â  Â  if (humanColor === 1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let err = checkForbidden(mousePos.r, mousePos.c);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (err) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  forbiddenMsg.innerText = `âš ï¸ ê¸ˆìˆ˜: ${err}`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let cx = margin + mousePos.c * cell; let cy = margin + mousePos.r * cell;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.strokeStyle = '#ff4444'; ctx.lineWidth = 4;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath(); ctx.moveTo(cx - 10, cy - 10); ctx.lineTo(cx + 10, cy + 10);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.moveTo(cx + 10, cy - 10); ctx.lineTo(cx - 10, cy + 10); ctx.stroke();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else forbiddenMsg.innerText = '';
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  if (moveHistory.length > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  let last = moveHistory[moveHistory.length-1];
Â  Â  Â  Â  Â  Â  Â  Â  let lx = margin + last.c * cell; let ly = margin + last.r * cell;
Â  Â  Â  Â  Â  Â  Â  Â  ctx.strokeStyle = '#55ff55'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(lx, ly, 18, 0, Math.PI*2); ctx.stroke();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  function drawStone(r, c, type) {
Â  Â  Â  Â  Â  Â  let cx = margin + c * cell; let cy = margin + r * cell;
Â  Â  Â  Â  Â  Â  let grad = ctx.createRadialGradient(cx - 5, cy - 5, 2, cx, cy, 15);
Â  Â  Â  Â  Â  Â  if (type === 1) { grad.addColorStop(0, '#333'); grad.addColorStop(1, '#000'); } else { grad.addColorStop(0, '#fff'); grad.addColorStop(1, '#ccc'); }Â 
Â  Â  Â  Â  Â  Â  ctx.fillStyle = grad; ctx.shadowColor = 'rgba(0,0,0,0.6)'; ctx.shadowBlur = 6; ctx.shadowOffsetY = 4;
Â  Â  Â  Â  Â  Â  ctx.beginPath(); ctx.arc(cx, cy, 16, 0, Math.PI*2); ctx.fill(); ctx.shadowColor = 'transparent';
Â  Â  Â  Â  }
Â  Â  Â  Â  window.resetVoid = () => {
Â  Â  Â  Â  Â  Â  board = Array.from({length: size}, () => Array(size).fill(0));
Â  Â  Â  Â  Â  Â  isGameOver = false; moveHistory = []; hintPos = null; forbiddenMap = []; humanColor = 1;Â 
Â  Â  Â  Â  Â  Â  updateRoleDisplay(); status.innerText = 'ğŸ”¥ HYPER-VOID GM READY'; forbiddenMsg.innerText = '';
Â  Â  Â  Â  Â  Â  worker.postMessage({type: 'RESET'}); drawBoard();
Â  Â  Â  Â  };
Â  Â  Â  Â  window.swapSides = () => {
Â  Â  Â  Â  Â  Â  if (moveHistory.length > 0) { alert("ê²Œì„ ë„ì¤‘ì—ëŠ” ë°”ê¿€ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë¦¬ë¶€íŠ¸ í›„ ë°”ê¾¸ì„¸ìš”."); return; }
Â  Â  Â  Â  Â  Â  humanColor = 3 - humanColor; updateRoleDisplay(); updateForbiddenMap(); drawBoard();
Â  Â  Â  Â  Â  Â  if (humanColor === 2) { status.innerText = 'ğŸ›¡ï¸ AI STARTING...'; worker.postMessage({ type: 'THINK', b: '0', w: '0', turn: 1, history: "" }); }Â 
Â  Â  Â  Â  Â  Â  else status.innerText = 'ğŸ”¥ YOU ARE BLACK';
Â  Â  Â  Â  };
Â  Â  Â  Â  function updateRoleDisplay() {
Â  Â  Â  Â  Â  Â  if (humanColor === 1) { uRole.innerText = "BLACK (First)"; uRole.style.color = "#888"; aRole.innerText = "WHITE (Second)"; aRole.style.color = "#fff"; }Â 
Â  Â  Â  Â  Â  Â  else { uRole.innerText = "WHITE (Second)"; uRole.style.color = "#fff"; aRole.innerText = "BLACK (First)"; aRole.style.color = "#888"; }
Â  Â  Â  Â  }
Â  Â  Â  Â  window.undoMove = () => {
Â  Â  Â  Â  Â  Â  if (moveHistory.length < 2 || isGameOver) return;
Â  Â  Â  Â  Â  Â  for(let k=0; k<2; k++) { let m = moveHistory.pop(); if(m) board[m.r][m.c] = 0; }
Â  Â  Â  Â  Â  Â  isGameOver = false; hintPos = null; updateForbiddenMap(); status.innerText = 'â†¶ UNDO DONE'; drawBoard();
Â  Â  Â  Â  };
Â  Â  Â  Â  function shakeBoard() { canvas.style.transform = "translateX(5px)"; setTimeout(() => canvas.style.transform = "translateX(-5px)", 50); setTimeout(() => canvas.style.transform = "translateX(0)", 100); }
Â  Â  Â  Â  function getMousePos(e) {
Â  Â  Â  Â  Â  Â  const rect = canvas.getBoundingClientRect(); const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height;
Â  Â  Â  Â  Â  Â  let x = (e.clientX - rect.left) * scaleX; let y = (e.clientY - rect.top) * scaleY;
Â  Â  Â  Â  Â  Â  return { c: Math.round((x - margin) / cell), r: Math.round((y - margin) / cell) };
Â  Â  Â  Â  }
Â  Â  Â  Â  canvas.onmousemove = (e) => {
Â  Â  Â  Â  Â  Â  if (isGameOver) return; let pos = getMousePos(e);
Â  Â  Â  Â  Â  Â  if (pos.r >= 0 && pos.r < size && pos.c >= 0 && pos.c < size) { if (!mousePos || mousePos.r !== pos.r || mousePos.c !== pos.c) { mousePos = pos; drawBoard(); } }Â 
Â  Â  Â  Â  Â  Â  else { if (mousePos) { mousePos = null; drawBoard(); } }
Â  Â  Â  Â  };
Â  Â  Â  Â  canvas.onmouseleave = () => { mousePos = null; drawBoard(); };
Â  Â  Â  Â  canvas.onclick = (e) => {
Â  Â  Â  Â  Â  Â  if (isGameOver || status.innerText.includes('AI')) return; let pos = getMousePos(e);
Â  Â  Â  Â  Â  Â  if (pos.r >= 0 && pos.r < size && pos.c >= 0 && pos.c < size) if (board[pos.r][pos.c] === 0) placeStone(pos.r, pos.c, humanColor);
Â  Â  Â  Â  };
Â  Â  Â  Â  drawBoard(); updateRoleDisplay(); status.innerText = 'ğŸš€ CLICK TO START';
Â  Â  })();
Â  Â  </script>
</body>
</html>

