import 'package:flutter/foundation.dart';
import '../models/game_state.dart';
import '../models/card.dart';
import '../utils/constants.dart';
import 'solver.dart';

class ExploitabilityCalculator {
  final Solver solver;
  final double ante;

  // ë””ë²„ê¹…ìš© ì¹´ìš´í„°
  int _visitedNodes = 0;
  int _missedNodes = 0; // í•™ìŠµëœ ë…¸ë“œë¥¼ ì°¾ì§€ ëª»í•œ íšŸìˆ˜

  ExploitabilityCalculator(this.solver, {this.ante = 1.0});

  double calculate() {
    double totalValueP0 = 0.0;
    double totalValueP1 = 0.0;
    int count = 0;

    _visitedNodes = 0;
    _missedNodes = 0;

    // ëª¨ë“  ì¹´ë“œ ì¡°í•© (10*9 = 90ê°€ì§€)
    for (int r1 = 1; r1 <= 10; r1++) {
      for (int r2 = 1; r2 <= 10; r2++) {
        if (r1 == r2) continue;

        // Case 1: AIê°€ P0
        var st0 = _createState(r1, r2, 0);
        totalValueP1 += _getBestResponse(st0, 1);

        // Case 2: AIê°€ P1
        var st1 = _createState(r1, r2, 0);
        totalValueP0 += _getBestResponse(st1, 0);

        count++;
      }
    }

    // ë…¸ë“œ ë¯¸ìŠ¤ìœ¨ ì¶œë ¥ (ì´ê²Œ ë†’ìœ¼ë©´ í•™ìŠµ í™˜ê²½ê³¼ í…ŒìŠ¤íŠ¸ í™˜ê²½ì´ ë‹¤ë¥¸ ê²ƒ)
    if (_visitedNodes > 0) {
      double missRate = (_missedNodes / _visitedNodes) * 100;
      // Isolate ë‚´ë¶€ì—ì„œëŠ” print ì‚¬ìš© (debugPrintëŠ” UI ìŠ¤ë ˆë“œìš©ì¼ ìˆ˜ ìˆìŒ)
      print(
        "ğŸ” [Exp Calc] Visited: $_visitedNodes | Missed: $_missedNodes (${missRate.toStringAsFixed(1)}%)",
      );
    }

    double rawLossPerHand = (totalValueP0 + totalValueP1) / (2 * count);
    return rawLossPerHand / ante;
  }

  GameState _createState(int r1, int r2, int startTurn) {
    // Solverì˜ í›ˆë ¨ í™˜ê²½ê³¼ ì •í™•íˆ ì¼ì¹˜ì‹œì¼œì•¼ í•¨ (Stack 80)
    var st = GameState(
      s0: 80.0,
      s1: 80.0,
      h1: GameCard(rank: r1, suit: 's'),
      h2: GameCard(rank: r2, suit: 'h'),
      ante: this.ante,
    );
    st.turn = startTurn;
    return st;
  }

  double _getBestResponse(GameState st, int bestResponder) {
    if (st.done) return st.payoff(bestResponder);

    List<Act> valid = st.validActs();
    if (valid.isEmpty) return 0.0;

    // Nemesis(ìƒëŒ€) í„´: Max Value ì„ íƒ
    if (st.turn == bestResponder) {
      double maxVal = -double.infinity;
      for (var act in valid) {
        var next = st.clone()..apply(act);
        double val = _getBestResponse(next, bestResponder);
        if (val > maxVal) maxVal = val;
      }
      return maxVal;
    }
    // AI í„´: í•™ìŠµëœ ì „ëµ ì‚¬ìš©
    else {
      String key = Solver.generateKey(st);
      Node? node = solver.nodes[key];

      List<double> strat;

      _visitedNodes++;
      if (node != null) {
        strat = node.getStrat(); // í•™ìŠµëœ ì „ëµ
      } else {
        _missedNodes++; // Key ë¶ˆì¼ì¹˜ ë°œìƒ!
        strat = List.filled(ACTION_COUNT, 1.0 / ACTION_COUNT); // ëœë¤
      }

      // Renormalization
      double probSum = 0.0;
      for (var act in valid) {
        probSum += strat[act.index];
      }

      strat = List.from(strat); // ì›ë³¸ ë³´ì¡´ì„ ìœ„í•´ ë³µì‚¬
      if (probSum > 1e-10) {
        // ì•„ì£¼ ì‘ì€ ê°’ì´ë¼ë„ í•©ì´ ìˆìœ¼ë©´
        for (int i = 0; i < strat.length; i++) {
          // ìœ íš¨í•œ ì•¡ì…˜ ë¦¬ìŠ¤íŠ¸ì— í¬í•¨ëœ indexë§Œ ë‚¨ê¸°ê³  ë‚˜ë¨¸ì§€ëŠ” 0
          bool isValid = valid.any((v) => v.index == i);
          if (isValid) {
            strat[i] /= probSum;
          } else {
            strat[i] = 0.0;
          }
        }
      } else {
        // í™•ë¥  í•©ì´ 0ì´ë©´ ê· ë“± ë°°ë¶„
        for (int i = 0; i < strat.length; i++) strat[i] = 0.0;
        double uniform = 1.0 / valid.length;
        for (var act in valid) strat[act.index] = uniform;
      }

      double expVal = 0.0;
      for (var act in valid) {
        if (strat[act.index] <= 0) continue;
        var next = st.clone()..apply(act);
        expVal += strat[act.index] * _getBestResponse(next, bestResponder);
      }
      return expVal;
    }
  }
}
